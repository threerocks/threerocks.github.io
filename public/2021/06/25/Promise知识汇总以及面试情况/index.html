<!DOCTYPE html><html lang="zh-tw,en,default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> Promise知识汇总以及面试情况 · 刘小磊的技术博客</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Promise知识汇总以及面试情况 - 刘小磊"><meta name="keywords"><meta name="author" content="刘小磊"><link rel="short icon" href="https://qiniu2.rrdnyyy.com/blog/a5ktx-bmwk7-002.ico"><link rel="stylesheet" href="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://threerocks.github.io/atom.xml" title="刘小磊的技术博客"><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src='//unpkg.com/valine/dist/Valine.min.js'></script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="刘小磊的技术博客" type="application/atom+xml">
</head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="https://qiniu2.rrdnyyy.com/blog/WechatIMG139.jpg"></a><ul id="nav_list" class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/categories/live/" target="_self" data-hover="生活" class="nav-list-link">生活</a></li><li class="nav-list-item"><a href="/categories/read/" target="_self" data-hover="读书" class="nav-list-link">读书</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div><div id="nav_btn" class="nav-btn"><span></span><span></span><span></span></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">Promise知识汇总以及面试情况</h1><div class="post-info">2021-06-25<p class="visit"><i data-identity="2021/06/25/Promise知识汇总以及面试情况/" class="article-timer"></i><span>次访问</span></p></div><div class="post-content"><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Javascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 <a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a> 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。   </p>
<p>关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。</p>
<span id="more"></span>

<h2 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h2><h3 id="规范解读"><a href="#规范解读" class="headerlink" title="规范解读"></a>规范解读</h3><p><a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a>规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版<a target="_blank" rel="noopener" href="https://promisesaplus.com/">Promise/A+</a>标准。</p>
<blockquote>
<p>1、<code>Promise</code>有三种状态<code>pending</code>，<code>fulfilled</code>和<code>rejected</code>。（为了一致性，此文章称<code>fulfilled</code>状态为<code>resolved</code>状态）</p>
<blockquote>
<ul>
<li>状态转换只能是<code>pending</code>到<code>resolved</code>或者<code>pending</code>到<code>rejected</code>；</li>
<li>状态一旦转换完成，不能再次转换。</li>
</ul>
</blockquote>
<p>2、Promise拥有一个then方法，用以处理<code>resolved</code>或<code>rejected</code>状态下的值。</p>
<blockquote>
<ul>
<li>then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。</li>
<li>then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise）<ul>
<li>onResolved/onRejected有返回值则把返回值定义为x，并执行[[Resolve]](promise2, x);</li>
<li>onResolved/onRejected运行出错，则把promise2设置为<code>rejected</code>状态；</li>
<li>onResolved/onRejected不是函数，则需要把promise1的状态传递下去。</li>
</ul>
</li>
</ul>
</blockquote>
<p>3、不同的Promise实现可以的交互。</p>
<blockquote>
<ul>
<li>规范中称这一步操作为Promise解决过程，函数标示为[[Resolve]](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。</li>
<li>[[Resolve]](promise, x)函数具体运行规则：<ul>
<li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise;</li>
<li>如果 x 为 Promise ，则使 promise 接受 x 的状态;</li>
<li>如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入<code>rejected</code>状态，如果then不是函数，同样让promise进入<code>rejected</code>状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用[[Resolve]](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入<code>rejected</code>状态；</li>
<li>如果 x 不是对象或者函数，直接就用x的值来执行promise。</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>规范解读第1条，代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义Promise状态变量，初始值为pending</span></span><br><span class="line">  status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="comment">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// resolve函数负责把状态转换为resolved</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject函数负责把状态转换为rejected</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>规范解读第2条，代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 拥有一个then方法</span></span><br><span class="line"><span class="comment">  * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class="line"><span class="comment">  * 返回一个新的Promise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> e &#125;;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="keyword">throw</span> e &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  </span><br><span class="line">  promise2 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态为resolved，则执行onResolved</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class="line">        <span class="keyword">const</span> x = onResolved(<span class="built_in">this</span>.data);</span><br><span class="line">        <span class="comment">// 执行[[Resolve]](promise2, x)</span></span><br><span class="line">        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果状态为rejected，则执行onRejected</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.data);</span><br><span class="line">        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下</p>
<ol>
<li>resolvePromise未定义；</li>
<li>then方法执行的时候，promise可能仍然处于<code>pending</code>状态，因为<code>executor</code>中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机；</li>
<li>onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的)</li>
</ol>
<p>解决办法：</p>
<ol>
<li>根据规范解读第3条，定义并实现resolvePromise函数；</li>
<li>then方法执行时如果promise仍然处于<code>pending</code>状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。</li>
<li>Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA">这篇文章</a>。</li>
</ol>
<p>好了，有了解决办法，我们就把代码进一步完善：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义Promise状态变量，初始值为pending</span></span><br><span class="line">  status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="comment">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">  onResolvedCallback = [];</span><br><span class="line">  <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">  onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// resolve函数负责把状态转换为resolved</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = value;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> <span class="built_in">this</span>.onResolvedCallback) &#123;</span><br><span class="line">        func(<span class="built_in">this</span>.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject函数负责把状态转换为rejected</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = reason;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> <span class="built_in">this</span>.onRejectedCallback) &#123;</span><br><span class="line">        func(<span class="built_in">this</span>.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 拥有一个then方法</span></span><br><span class="line"><span class="comment">    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class="line"><span class="comment">    * 返回一个新的Promise</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> e &#125;;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="keyword">throw</span> e &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line"></span><br><span class="line">    promise2 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果状态为resolved，则执行onResolved</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class="line">            <span class="keyword">const</span> x = onResolved(<span class="built_in">this</span>.data);</span><br><span class="line">            <span class="comment">// 执行[[Resolve]](promise2, x)</span></span><br><span class="line">            <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果状态为rejected，则执行onRejected</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.data);</span><br><span class="line">            <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果状态为pending，则把处理函数进行存储</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onResolved(<span class="built_in">this</span>.data);</span><br><span class="line">              <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.data);</span><br><span class="line">              <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [[Resolve]](promise2, x)函数</span></span><br><span class="line">  <span class="function"><span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，规范中关于then的部分就全部实现完毕了。</p>
<p>规范解读第3条，代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[Resolve]](promise2, x)函数</span></span><br><span class="line">  <span class="function"><span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise!&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果x仍然为Promise的情况</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise</span></span><br><span class="line">      <span class="keyword">if</span> (x.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 如果x状态已经确定了，直接取它的状态</span></span><br><span class="line">        x.then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="built_in">Object</span>.prototype.toString(x) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="built_in">Object</span>.prototype.toString(x) === <span class="string">&#x27;[object Function]&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制</span></span><br><span class="line">        <span class="keyword">const</span> then = x.then </span><br><span class="line">        <span class="comment">// then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">          then.call(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;, <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果then不是函数，那就说明x不是thenable，直接resolve x</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>这一步骤非常简单，只要按照规范转换成代码即可。</p>
<p>最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。</p>
<h3 id="Promise其他方法实现"><a href="#Promise其他方法实现" class="headerlink" title="Promise其他方法实现"></a>Promise其他方法实现</h3><h4 id="1、catch方法"><a href="#1、catch方法" class="headerlink" title="1、catch方法"></a>1、catch方法</h4><p>catch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2、done方法"><a href="#2、done方法" class="headerlink" title="2、done方法"></a>2、done方法</h4><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">done</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>, reason);</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3、finally方法"><a href="#3、finally方法" class="headerlink" title="3、finally方法"></a>3、finally方法</h4><p>finally方法用于无论是resolve还是reject，finally的参数函数都会被执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">finally</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4、Promise-all方法"><a href="#4、Promise-all方法" class="headerlink" title="4、Promise.all方法"></a>4、Promise.all方法</h4><p>Promise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为<code>resolved</code>时，promise2状态为<code>resolved</code>并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseList</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promiseList) &#123;</span><br><span class="line">      p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">        <span class="keyword">if</span> (result.length === promiseList.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5、Promise-race方法"><a href="#5、Promise-race方法" class="headerlink" title="5、Promise.race方法"></a>5、Promise.race方法</h4><p>Promise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseList</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promiseList) &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);   </span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6、Promise-resolve方法-Promise-reject"><a href="#6、Promise-resolve方法-Promise-reject" class="headerlink" title="6、Promise.resolve方法/Promise.reject"></a>6、Promise.resolve方法/Promise.reject</h4><p>Promise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> promise;</span><br><span class="line"></span><br><span class="line">  promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resolvePromise(promise, value, resolve, reject);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。</p>
<h2 id="Promise面试相关"><a href="#Promise面试相关" class="headerlink" title="Promise面试相关"></a>Promise面试相关</h2><p>面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。<br>Promise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。</p>
<h3 id="简单介绍下Promise。"><a href="#简单介绍下Promise。" class="headerlink" title="简单介绍下Promise。"></a>简单介绍下Promise。</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的）</p>
<ul>
<li>提问概率：99%</li>
<li>评分标准：人性化判断即可，此问题一般作为引入问题。</li>
<li>加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。</li>
</ul>
<h3 id="实现一个简单的，支持异步链式调用的Promise类。"><a href="#实现一个简单的，支持异步链式调用的Promise类。" class="headerlink" title="实现一个简单的，支持异步链式调用的Promise类。"></a>实现一个简单的，支持异步链式调用的Promise类。</h3><p>这个答案不是固定的，可以参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904094079926286">最简实现 Promise，支持异步链式调用</a></p>
<ul>
<li>提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识）</li>
<li>加分项：onResolved/onRejected函数异步调用，错误捕获合理等</li>
</ul>
<h3 id="Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序"><a href="#Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序" class="headerlink" title="Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)"></a>Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)</h3><p>JS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）<br>Event Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）<br>浏览器运行机制可参考<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA">这篇文章</a></p>
<ul>
<li>提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解）</li>
<li>加分项：扩展讲述浏览器运行机制。</li>
</ul>
<h3 id="阐述Promise的一些方法。"><a href="#阐述Promise的一些方法。" class="headerlink" title="阐述Promise的一些方法。"></a>阐述Promise的一些方法。</h3><p>Promise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等</p>
<ul>
<li>提问概率：25%</li>
<li>加分项：越多越好</li>
</ul>
<h3 id="Promise存在哪些缺点。"><a href="#Promise存在哪些缺点。" class="headerlink" title="Promise存在哪些缺点。"></a>Promise存在哪些缺点。</h3><p>1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）<br>4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p>
<ul>
<li>提问概率：25%（此问题作为提高题目，出现概率不高）</li>
<li>加分项：越多越合理越好</li>
</ul>
<h3 id="使用Promise进行顺序（sequence）处理。"><a href="#使用Promise进行顺序（sequence）处理。" class="headerlink" title="使用Promise进行顺序（sequence）处理。"></a>使用Promise进行顺序（sequence）处理。</h3><p>1、使用async函数配合await或者使用generator函数配合yield。<br>2、使用promise.then通过for循环或者Array.prototype.reduce实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">    <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(<span class="function">() =&gt;</span> task).then(pushValue);</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用）</li>
<li>评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。</li>
</ul>
<h3 id="如何停止一个Promise链？"><a href="#如何停止一个Promise链？" class="headerlink" title="如何停止一个Promise链？"></a>如何停止一个Promise链？</h3><p>在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.cancel = <span class="built_in">Promise</span>.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提问概率：50%（此问题主要考察面试者罗辑思维）</li>
</ul>
<h3 id="Promise链上返回的最后一个Promise出错了怎么办？"><a href="#Promise链上返回的最后一个Promise出错了怎么办？" class="headerlink" title="Promise链上返回的最后一个Promise出错了怎么办？"></a>Promise链上返回的最后一个Promise出错了怎么办？</h3><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">done</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>, reason);</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度）</li>
<li>加分项：给出具体的done()方法代码</li>
</ul>
<h3 id="Promise存在哪些使用技巧或者最佳实践？"><a href="#Promise存在哪些使用技巧或者最佳实践？" class="headerlink" title="Promise存在哪些使用技巧或者最佳实践？"></a>Promise存在哪些使用技巧或者最佳实践？</h3><p>1、链式Promise要返回一个Promise，而不只是构造一个Promise。<br>2、合理的使用Promise.all和Promise.race等方法。<br>3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。</p>
<ul>
<li>提问概率：10%（出题概率极低的一个题目）</li>
<li>加分项：越多越好</li>
</ul>
<p>参考链接：<br><a target="_blank" rel="noopener" href="http://liubin.org/promises-book/">http://liubin.org/promises-book</a><br><a target="_blank" rel="noopener" href="https://github.com/xieranmaya/blog/issues/3">https://github.com/xieranmaya/blog/issues/3</a><br><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016550260">https://segmentfault.com/a/1190000016550260</a></p>
</div></article></div><div class="right-container"><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2021/06/25/Redis%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%20-%20%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%EF%BC%88Node.js%E7%89%88%E6%9C%AC%EF%BC%89/" title="Redis应用实战 - 秒杀场景（Node.js版本）" class="next">NEXT</a></div><a href="#comment" class="comment-anchor"></a><div id="vcomments"></div><script>new Valine({
    el: "#vcomments",
    appId: "aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz",
    appKey: "FdzS5SOPHdhYQoEUngQ8K2QW",
    notify: false,
    verify: false,
    avatar: "robohash",
    visitor: true,
    placeholder: "随便说点什么～.～",
});</script><div class="copyright"><p>© 2016 - 2021 <a target="_blank">刘小磊</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p><p> <span style="padding-right: 6px;">闽ICP备16007301号-2</span></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/jquery-1.8.2.min.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/articleCatalog.js"></script><script src="https://bubuzou.oss-cn-shenzhen.aliyuncs.com/blog/202010/main.js"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>const valineAPI = (() => {
try {
    AV.init("aD8jJBpu4oew3ovNY73z6Rdq-gzGzoHsz", "FdzS5SOPHdhYQoEUngQ8K2QW");
} catch(error) {}
const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
    query.equalTo("identity", identity);
    query.find().then(results => {
        resolve(results.length > 0);
    }, error => reject(error));
    })
}

const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
    let querys = [];
    for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
    }
    query = AV.Query.or.apply(null ,querys);
    } else {
    identity = identity || getRealPath();
    query = new AV.Query("Timer");
    query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
    query.find()
    .then(results => resolve(results))
    .catch(error => reject(error))
    })
}

const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let Todo = AV.Object.extend('Timer');
    let todo = new Todo();
    todo.set("times", 1);
    todo.set("identity", identity);
    todo.save().then(res => resolve(true), error => reject(error));
    })
}

const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
    let query = new AV.Query('Timer');
    query.equalTo("identity", identity);
    query.find().then(todos => {
        todos.forEach(todo => {
        todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
    }).then(todos => resolve(true), error => reject(error));
    })
}

return {
    isExist,
    _get,
    update,
    create
}
})()

const calcAndWriteTimes = () => {
let isPost = true;

let timerAllDOM = document.querySelectorAll(".article-timer");

if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
    if(exist) {
        return valineAPI.update(identity);
    }
    return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
}

let timerDOMCache = {};

for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
    timerDOMCache[identity].dom.push(timerDOM);
    }else{
    timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
    };
    }
}

let identities = Object.keys(timerDOMCache);
valineAPI._get(identities).then(results => {
    for(let result of results) {
    let {identity, times} = result.attributes;
    timerDOMCache[identity].times = times;
    timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
    if(timerDOMCache[identity].times){
        continue;
    }
    timerDOMCache[identity].dom.map(item => item.innerText = 1);
    valineAPI.create(identity);
    }
}).catch(error => console.log(error.message))
}

if(true){
calcAndWriteTimes();
}</script></body></html>