<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Promise知识汇总以及面试情况</title>
      <link href="/2021/06/25/Promise%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BB%A5%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%83%85%E5%86%B5/"/>
      <url>/2021/06/25/Promise%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BB%A5%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>Javascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 <a href="https://promisesaplus.com/">Promise/A+</a> 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。   </p><p>关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。</p><span id="more"></span><h2 id="实现Promise"><a href="#实现Promise" class="headerlink" title="实现Promise"></a>实现Promise</h2><h3 id="规范解读"><a href="#规范解读" class="headerlink" title="规范解读"></a>规范解读</h3><p><a href="https://promisesaplus.com/">Promise/A+</a>规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版<a href="https://promisesaplus.com/">Promise/A+</a>标准。</p><blockquote><p>1、<code>Promise</code>有三种状态<code>pending</code>，<code>fulfilled</code>和<code>rejected</code>。（为了一致性，此文章称<code>fulfilled</code>状态为<code>resolved</code>状态）</p><blockquote><ul><li>状态转换只能是<code>pending</code>到<code>resolved</code>或者<code>pending</code>到<code>rejected</code>；</li><li>状态一旦转换完成，不能再次转换。</li></ul></blockquote><p>2、Promise拥有一个then方法，用以处理<code>resolved</code>或<code>rejected</code>状态下的值。</p><blockquote><ul><li>then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。</li><li>then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise）<ul><li>onResolved/onRejected有返回值则把返回值定义为x，并执行[[Resolve]](promise2, x);</li><li>onResolved/onRejected运行出错，则把promise2设置为<code>rejected</code>状态；</li><li>onResolved/onRejected不是函数，则需要把promise1的状态传递下去。</li></ul></li></ul></blockquote><p>3、不同的Promise实现可以的交互。</p><blockquote><ul><li>规范中称这一步操作为Promise解决过程，函数标示为[[Resolve]](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。</li><li>[[Resolve]](promise, x)函数具体运行规则：<ul><li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise;</li><li>如果 x 为 Promise ，则使 promise 接受 x 的状态;</li><li>如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入<code>rejected</code>状态，如果then不是函数，同样让promise进入<code>rejected</code>状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用[[Resolve]](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入<code>rejected</code>状态；</li><li>如果 x 不是对象或者函数，直接就用x的值来执行promise。</li></ul></li></ul></blockquote></blockquote><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>规范解读第1条，代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义Promise状态变量，初始值为pending</span></span><br><span class="line">  status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="comment">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// resolve函数负责把状态转换为resolved</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject函数负责把状态转换为rejected</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = reason;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>规范解读第2条，代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 拥有一个then方法</span></span><br><span class="line"><span class="comment">  * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class="line"><span class="comment">  * 返回一个新的Promise</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class="line">  onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> e &#125;;</span><br><span class="line">  onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="keyword">throw</span> e &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> promise2;</span><br><span class="line">  </span><br><span class="line">  promise2 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果状态为resolved，则执行onResolved</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class="line">        <span class="keyword">const</span> x = onResolved(<span class="built_in">this</span>.data);</span><br><span class="line">        <span class="comment">// 执行[[Resolve]](promise2, x)</span></span><br><span class="line">        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果状态为rejected，则执行onRejected</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.data);</span><br><span class="line">        resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> promise2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下</p><ol><li>resolvePromise未定义；</li><li>then方法执行的时候，promise可能仍然处于<code>pending</code>状态，因为<code>executor</code>中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机；</li><li>onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的)</li></ol><p>解决办法：</p><ol><li>根据规范解读第3条，定义并实现resolvePromise函数；</li><li>then方法执行时如果promise仍然处于<code>pending</code>状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。</li><li>Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐<a href="https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA">这篇文章</a>。</li></ol><p>好了，有了解决办法，我们就把代码进一步完善：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义Promise状态变量，初始值为pending</span></span><br><span class="line">  status = <span class="string">&#x27;pending&#x27;</span>;</span><br><span class="line">  <span class="comment">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class="line">  data = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="comment">// Promise resolve时的回调函数集</span></span><br><span class="line">  onResolvedCallback = [];</span><br><span class="line">  <span class="comment">// Promise reject时的回调函数集</span></span><br><span class="line">  onRejectedCallback = [];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">executor</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// resolve函数负责把状态转换为resolved</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;resolved&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = value;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> <span class="built_in">this</span>.onResolvedCallback) &#123;</span><br><span class="line">        func(<span class="built_in">this</span>.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// reject函数负责把状态转换为rejected</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.status = <span class="string">&#x27;rejected&#x27;</span>;</span><br><span class="line">      <span class="built_in">this</span>.data = reason;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> func <span class="keyword">of</span> <span class="built_in">this</span>.onRejectedCallback) &#123;</span><br><span class="line">        func(<span class="built_in">this</span>.data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 拥有一个then方法</span></span><br><span class="line"><span class="comment">    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class="line"><span class="comment">    * 返回一个新的Promise</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="function"><span class="title">then</span>(<span class="params">onResolved, onRejected</span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class="line">    onResolved = <span class="keyword">typeof</span> onResolved === <span class="string">&#x27;function&#x27;</span> ? onResolved : <span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123; <span class="keyword">return</span> e &#125;;</span><br><span class="line">    onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">&#x27;function&#x27;</span> ? onRejected : <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; <span class="keyword">throw</span> e &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> promise2;</span><br><span class="line"></span><br><span class="line">    promise2 =  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果状态为resolved，则执行onResolved</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;resolved&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class="line">            <span class="keyword">const</span> x = onResolved(<span class="built_in">this</span>.data);</span><br><span class="line">            <span class="comment">// 执行[[Resolve]](promise2, x)</span></span><br><span class="line">            <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果状态为rejected，则执行onRejected</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status === <span class="string">&#x27;rejected&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.data);</span><br><span class="line">            <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果状态为pending，则把处理函数进行存储</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.status = <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.onResolvedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onResolved(<span class="built_in">this</span>.data);</span><br><span class="line">              <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">this</span>.onRejectedCallback.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">const</span> x = onRejected(<span class="built_in">this</span>.data);</span><br><span class="line">              <span class="built_in">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">              reject(e);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;, <span class="number">0</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> promise2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// [[Resolve]](promise2, x)函数</span></span><br><span class="line">  <span class="function"><span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，规范中关于then的部分就全部实现完毕了。</p><p>规范解读第3条，代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [[Resolve]](promise2, x)函数</span></span><br><span class="line">  <span class="function"><span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> called = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (promise2 === x) &#123;</span><br><span class="line">      <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Chaining cycle detected for promise!&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果x仍然为Promise的情况</span></span><br><span class="line">    <span class="keyword">if</span> (x <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise</span></span><br><span class="line">      <span class="keyword">if</span> (x.status === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">        x.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">          resolvePromise(promise2, value, resolve, reject)</span><br><span class="line">        &#125;, reject)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 如果x状态已经确定了，直接取它的状态</span></span><br><span class="line">        x.then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (x !== <span class="literal">null</span> &amp;&amp; (<span class="built_in">Object</span>.prototype.toString(x) === <span class="string">&#x27;[object Object]&#x27;</span> || <span class="built_in">Object</span>.prototype.toString(x) === <span class="string">&#x27;[object Function]&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制</span></span><br><span class="line">        <span class="keyword">const</span> then = x.then </span><br><span class="line">        <span class="comment">// then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123; </span><br><span class="line">          then.call(x, <span class="function">(<span class="params">y</span>) =&gt;</span> &#123; </span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">this</span>.resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">          &#125;, <span class="function">(<span class="params">r</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">            called = <span class="literal">true</span>;</span><br><span class="line">            reject(r);</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果then不是函数，那就说明x不是thenable，直接resolve x</span></span><br><span class="line">          <span class="keyword">if</span> (called) <span class="keyword">return</span> ;</span><br><span class="line">          called = <span class="literal">true</span>;</span><br><span class="line">          resolve(x);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">        called = <span class="literal">true</span>;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      resolve(x);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这一步骤非常简单，只要按照规范转换成代码即可。</p><p>最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。</p><h3 id="Promise其他方法实现"><a href="#Promise其他方法实现" class="headerlink" title="Promise其他方法实现"></a>Promise其他方法实现</h3><h4 id="1、catch方法"><a href="#1、catch方法" class="headerlink" title="1、catch方法"></a>1、catch方法</h4><p>catch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onRejected);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、done方法"><a href="#2、done方法" class="headerlink" title="2、done方法"></a>2、done方法</h4><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">done</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>, reason);</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、finally方法"><a href="#3、finally方法" class="headerlink" title="3、finally方法"></a>3、finally方法</h4><p>finally方法用于无论是resolve还是reject，finally的参数函数都会被执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">finally</span>(<span class="params">fn</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;, <span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    fn();</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4、Promise-all方法"><a href="#4、Promise-all方法" class="headerlink" title="4、Promise.all方法"></a>4、Promise.all方法</h4><p>Promise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为<code>resolved</code>时，promise2状态为<code>resolved</code>并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">all</span>(<span class="params">promiseList</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promiseList) &#123;</span><br><span class="line">      p.then(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        result[i] = value;</span><br><span class="line">        <span class="keyword">if</span> (result.length === promiseList.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, reject);</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5、Promise-race方法"><a href="#5、Promise-race方法" class="headerlink" title="5、Promise.race方法"></a>5、Promise.race方法</h4><p>Promise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">race</span>(<span class="params">promiseList</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> p <span class="keyword">of</span> promiseList) &#123;</span><br><span class="line">      p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">        resolve(value);   </span><br><span class="line">      &#125;, reject);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6、Promise-resolve方法-Promise-reject"><a href="#6、Promise-resolve方法-Promise-reject" class="headerlink" title="6、Promise.resolve方法/Promise.reject"></a>6、Promise.resolve方法/Promise.reject</h4><p>Promise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">resolve</span>(<span class="params">value</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> promise;</span><br><span class="line"></span><br><span class="line">  promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.resolvePromise(promise, value, resolve, reject);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="function"><span class="title">reject</span>(<span class="params">reason</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    reject(reason);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。</p><h2 id="Promise面试相关"><a href="#Promise面试相关" class="headerlink" title="Promise面试相关"></a>Promise面试相关</h2><p>面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。<br>Promise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。</p><h3 id="简单介绍下Promise。"><a href="#简单介绍下Promise。" class="headerlink" title="简单介绍下Promise。"></a>简单介绍下Promise。</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的）</p><ul><li>提问概率：99%</li><li>评分标准：人性化判断即可，此问题一般作为引入问题。</li><li>加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。</li></ul><h3 id="实现一个简单的，支持异步链式调用的Promise类。"><a href="#实现一个简单的，支持异步链式调用的Promise类。" class="headerlink" title="实现一个简单的，支持异步链式调用的Promise类。"></a>实现一个简单的，支持异步链式调用的Promise类。</h3><p>这个答案不是固定的，可以参考<a href="https://juejin.cn/post/6844904094079926286">最简实现 Promise，支持异步链式调用</a></p><ul><li>提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识）</li><li>加分项：onResolved/onRejected函数异步调用，错误捕获合理等</li></ul><h3 id="Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序"><a href="#Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序" class="headerlink" title="Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)"></a>Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)</h3><p>JS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）<br>Event Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）<br>浏览器运行机制可参考<a href="https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA">这篇文章</a></p><ul><li>提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解）</li><li>加分项：扩展讲述浏览器运行机制。</li></ul><h3 id="阐述Promise的一些方法。"><a href="#阐述Promise的一些方法。" class="headerlink" title="阐述Promise的一些方法。"></a>阐述Promise的一些方法。</h3><p>Promise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等</p><ul><li>提问概率：25%</li><li>加分项：越多越好</li></ul><h3 id="Promise存在哪些缺点。"><a href="#Promise存在哪些缺点。" class="headerlink" title="Promise存在哪些缺点。"></a>Promise存在哪些缺点。</h3><p>1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）<br>4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p><ul><li>提问概率：25%（此问题作为提高题目，出现概率不高）</li><li>加分项：越多越合理越好</li></ul><h3 id="使用Promise进行顺序（sequence）处理。"><a href="#使用Promise进行顺序（sequence）处理。" class="headerlink" title="使用Promise进行顺序（sequence）处理。"></a>使用Promise进行顺序（sequence）处理。</h3><p>1、使用async函数配合await或者使用generator函数配合yield。<br>2、使用promise.then通过for循环或者Array.prototype.reduce实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">        results.push(value);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">    <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promise.then(<span class="function">() =&gt;</span> task).then(pushValue);</span><br><span class="line">    &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用）</li><li>评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。</li></ul><h3 id="如何停止一个Promise链？"><a href="#如何停止一个Promise链？" class="headerlink" title="如何停止一个Promise链？"></a>如何停止一个Promise链？</h3><p>在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.cancel = <span class="built_in">Promise</span>.stop = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提问概率：50%（此问题主要考察面试者罗辑思维）</li></ul><h3 id="Promise链上返回的最后一个Promise出错了怎么办？"><a href="#Promise链上返回的最后一个Promise出错了怎么办？" class="headerlink" title="Promise链上返回的最后一个Promise出错了怎么办？"></a>Promise链上返回的最后一个Promise出错了怎么办？</h3><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">done</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.catch(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>, reason);</span><br><span class="line">    <span class="keyword">throw</span> reason;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度）</li><li>加分项：给出具体的done()方法代码</li></ul><h3 id="Promise存在哪些使用技巧或者最佳实践？"><a href="#Promise存在哪些使用技巧或者最佳实践？" class="headerlink" title="Promise存在哪些使用技巧或者最佳实践？"></a>Promise存在哪些使用技巧或者最佳实践？</h3><p>1、链式Promise要返回一个Promise，而不只是构造一个Promise。<br>2、合理的使用Promise.all和Promise.race等方法。<br>3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。</p><ul><li>提问概率：10%（出题概率极低的一个题目）</li><li>加分项：越多越好</li></ul><p>参考链接：<br><a href="http://liubin.org/promises-book/">http://liubin.org/promises-book</a><br><a href="https://github.com/xieranmaya/blog/issues/3">https://github.com/xieranmaya/blog/issues/3</a><br><a href="https://segmentfault.com/a/1190000016550260">https://segmentfault.com/a/1190000016550260</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Promise </tag>
            
            <tag> Node.js </tag>
            
            <tag> Javascript </tag>
            
            <tag> ES6 </tag>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis应用实战 - 秒杀场景（Node.js版本）</title>
      <link href="/2021/06/25/Redis%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%20-%20%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%EF%BC%88Node.js%E7%89%88%E6%9C%AC%EF%BC%89/"/>
      <url>/2021/06/25/Redis%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%20-%20%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%EF%BC%88Node.js%E7%89%88%E6%9C%AC%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>公司随着业务量的增加，最近用时几个月时间在项目中全面接入<code>Redis</code>，开发过程中发现市面上缺少具体的实战资料，尤其是在<code>Node.js</code>环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍<code>Redis</code>的几个使用场景，期望大家一起学习、进步。<br>下面就开始第一篇，秒杀场景。</p><h2 id="业务分析"><a href="#业务分析" class="headerlink" title="业务分析"></a>业务分析</h2><p>实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下：</p><ol><li>秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用<code>CDN</code>或者是浏览器进行缓存。</li><li>秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是<ul><li>短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高）</li><li>请求数量大于商品库存，比如10000个用户抢购，但是库存只有100</li><li>限定用户只能在一定时间段内购买</li><li>限制单个用户购买数量，避免刷单</li><li>抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数</li><li>对数据库的操作读多写少，而且读操作相对简单</li></ul></li><li>秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。</li></ol><p>根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。</p><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>数据库：<code>Redis 3.2.9</code> + <code>Mysql 5.7.18</code><br>服务器：<code>Node.js v10.15.0</code><br>测试工具：<code>Jmeter-5.4.1</code></p><span id="more"></span><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><h3 id="数据库准备"><a href="#数据库准备" class="headerlink" title="数据库准备"></a>数据库准备</h3><p><img src="media/16239877134495/tables.jpg" alt="tables"><br>如图所示，<code>Mysql</code>中需要创建三张表，分别是</p><ul><li>产品表，用于记录产品信息，字段分别为Id、名称、缩略图、价格和状态等等</li><li>秒杀活动表，用于记录秒杀活动的详细信息，字段分别为Id、参与秒杀的产品Id、库存量、秒杀开始时间、秒杀结束时间和秒杀活动是否有效等等</li><li>订单表，用于记录下单后的数据，字段分别为Id、订单号、产品Id、购买用户Id、订单状态、订单类型和秒杀活动Id等等</li></ul><p>下面是创建<code>sql</code>语句，以供参考</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `scekill_goods` (</span><br><span class="line">`id` <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">`fk_good_id` <span class="type">INTEGER</span>,</span><br><span class="line">`amount` <span class="type">INTEGER</span>,</span><br><span class="line">`start_time` DATETIME,</span><br><span class="line">`end_time` DATETIME,</span><br><span class="line">`is_valid` TINYINT ( <span class="number">1</span> ),</span><br><span class="line">`comment` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`created_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`updated_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `orders` (</span><br><span class="line">`id` <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">`order_no` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`good_id` <span class="type">INTEGER</span>,</span><br><span class="line">`user_id` <span class="type">INTEGER</span>,</span><br><span class="line">`status` ENUM ( <span class="string">&#x27;-1&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span> ),</span><br><span class="line">`order_type` ENUM ( <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span> ),</span><br><span class="line">`scekill_id` <span class="type">INTEGER</span>,</span><br><span class="line">`comment` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`created_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`updated_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `goods` (</span><br><span class="line">`id` <span class="type">INTEGER</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> auto_increment,</span><br><span class="line">`name` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`thumbnail` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`price` <span class="type">INTEGER</span>,</span><br><span class="line">`status` TINYINT ( <span class="number">1</span> ),</span><br><span class="line">`stock` <span class="type">INTEGER</span>,</span><br><span class="line">`stock_left` <span class="type">INTEGER</span>,</span><br><span class="line">`description` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`comment` <span class="type">VARCHAR</span> ( <span class="number">255</span> ),</span><br><span class="line">`created_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`updated_at` DATETIME <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY ( `id` ) </span><br><span class="line">) ENGINE <span class="operator">=</span> INNODB <span class="keyword">DEFAULT</span> CHARSET <span class="operator">=</span> utf8mb4;</span><br></pre></td></tr></table></figure><p>产品表在此次业务中不是重点，以下逻辑都以<code>id=1</code>的产品为示例，请悉知。<br>秒杀活动表中创建一条库存为200的记录，作为秒杀测试数据，参考下面语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `redis_app`.`seckill_goods` (</span><br><span class="line">`id`,</span><br><span class="line">`fk_good_id`,</span><br><span class="line">`amount`,</span><br><span class="line">`start_time`,</span><br><span class="line">`end_time`,</span><br><span class="line">`is_valid`,</span><br><span class="line">`comment`,</span><br><span class="line">`created_at`,</span><br><span class="line">`updated_at` </span><br><span class="line">)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="number">200</span>,</span><br><span class="line"><span class="string">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2023-06-20 00:00:00&#x27;</span>,</span><br><span class="line"><span class="number">1</span>,</span><br><span class="line"><span class="string">&#x27;...&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;2021-06-22 10:18:16&#x27;</span> </span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="秒杀接口开发"><a href="#秒杀接口开发" class="headerlink" title="秒杀接口开发"></a>秒杀接口开发</h3><p>首先，说一下<code>Node.js</code>中的具体开发环境:</p><ul><li><code>web</code>框架使用<code>Koa2</code></li><li><code>mysql</code>操作使用基于<code>promise</code>的<code>Node.js</code> <code>ORM</code>工具<code>Sequelize</code></li><li><code>redis</code>操作使用<code>ioredis</code>库</li><li>封装<code>ctx.throwException</code>方法用于处理错误，封装<code>ctx.send</code>方法用于返回正确结果，具体实现参考文末完整代码</li></ul><p>其次，分析一下接口要处理的逻辑，大概步骤和顺序如下：</p><ol><li>基本参数校验</li><li>判断产品是否加入了抢购</li><li>判断秒杀活动是否有效</li><li>判断秒杀活动是否开始、结束</li><li>判断秒杀商品是否卖完</li><li>获取登录用户信息</li><li>判断登录用户是否已抢到</li><li>扣库存</li><li>下单</li></ol><p>最后，根据分析把以上步骤用代码进行初步实现，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入moment库处理时间相关数据</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入数据库model文件</span></span><br><span class="line"><span class="keyword">const</span> seckillModel = <span class="built_in">require</span>(<span class="string">&#x27;../../dbs/mysql/models/seckill_goods&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ordersModel = <span class="built_in">require</span>(<span class="string">&#x27;../../dbs/mysql/models/orders&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入工具函数或工具类</span></span><br><span class="line"><span class="keyword">const</span> UserModule = <span class="built_in">require</span>(<span class="string">&#x27;../modules/user&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; random_String &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../utils/tools/funcs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seckill</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 秒杀接口</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * <span class="doctag">@method <span class="variable">post</span></span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>good_id 产品id</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>accessToken 用户Token</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param </span>path 秒杀完成后跳转路径</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">doSeckill</span>(<span class="params">ctx, next</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = ctx.request.body;</span><br><span class="line">    <span class="keyword">const</span> accessToken = ctx.query.accessToken;</span><br><span class="line">    <span class="keyword">const</span> path = body.path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!accessToken || !path) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">20001</span>, <span class="string">&#x27;参数错误！&#x27;</span>); &#125;;</span><br><span class="line">    <span class="comment">// 判断此产品是否加入了抢购</span></span><br><span class="line">    <span class="keyword">const</span> seckill = <span class="keyword">await</span> seckillModel.findOne(&#123;</span><br><span class="line">      <span class="attr">where</span>: &#123;</span><br><span class="line">        <span class="attr">fk_good_id</span>: ctx.params.good_id,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (!seckill) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30002</span>, <span class="string">&#x27;该产品并未有抢购活动！&#x27;</span>); &#125;;</span><br><span class="line">    <span class="comment">// 判断是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!seckill.is_valid) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30003</span>, <span class="string">&#x27;该活动已结束！&#x27;</span>); &#125;;</span><br><span class="line">    <span class="comment">// 判单是否开始、结束</span></span><br><span class="line">    <span class="keyword">if</span>(moment().isBefore(moment(seckill.start_time))) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.throwException(<span class="number">30004</span>, <span class="string">&#x27;该抢购活动还未开始！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(moment().isAfter(moment(seckill.end_time))) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.throwException(<span class="number">30005</span>, <span class="string">&#x27;该抢购活动已经结束！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否卖完</span></span><br><span class="line">    <span class="keyword">if</span>(seckill.amount &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30006</span>, <span class="string">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的accessToken校验流程)</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">await</span> UserModule.getUserInfo(accessToken);</span><br><span class="line">    <span class="keyword">if</span> (!userInfo) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">10002</span>, <span class="string">&#x27;用户不存在！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断登录用户是否已抢到（一个用户针对这次活动只能购买一次）</span></span><br><span class="line">    <span class="keyword">const</span> orderInfo = <span class="keyword">await</span> ordersModel.findOne(&#123;</span><br><span class="line">      <span class="attr">where</span>: &#123;</span><br><span class="line">        <span class="attr">user_id</span>: userInfo.id,</span><br><span class="line">        <span class="attr">seckill_id</span>: seckill.id,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (orderInfo) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30007</span>, <span class="string">&#x27;该用户已抢到该产品，无需再抢！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扣库存</span></span><br><span class="line">    <span class="keyword">const</span> count = <span class="keyword">await</span> seckill.decrement(<span class="string">&#x27;amount&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> (count.amount &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30006</span>, <span class="string">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下单</span></span><br><span class="line">    <span class="keyword">const</span> orderData = &#123;</span><br><span class="line">      <span class="attr">order_no</span>: <span class="built_in">Date</span>.now() + random_String(<span class="number">4</span>), <span class="comment">// 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 </span></span><br><span class="line">      <span class="attr">good_id</span>: ctx.params.good_id,</span><br><span class="line">      <span class="attr">user_id</span>: userInfo.id,</span><br><span class="line">      <span class="attr">status</span>: <span class="string">&#x27;1&#x27;</span>, <span class="comment">// -1 已取消, 0 未付款， 1 已付款， 2已退款</span></span><br><span class="line">      <span class="attr">order_type</span>: <span class="string">&#x27;2&#x27;</span>, <span class="comment">// 1 常规订单 2 秒杀订单</span></span><br><span class="line">      <span class="attr">seckill_id</span>: seckill.id, <span class="comment">// 秒杀活动id</span></span><br><span class="line">      <span class="attr">comment</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 备注</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">const</span> order = ordersModel.create(orderData);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!order) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30008</span>, <span class="string">&#x27;抢购失败!&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    ctx.send(&#123;</span><br><span class="line">      path,</span><br><span class="line">      <span class="attr">data</span>: <span class="string">&#x27;抢购成功!&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Seckill();</span><br></pre></td></tr></table></figure><p>至此，秒杀接口用传统的关系型数据库就实现完成了，代码并不复杂，注释也很详细，不用特别的讲解大家也都能看懂，那它能不能正常工作呢，答案显然是否定的<br>通过<code>Jmeter</code>模拟以下测试：</p><ul><li>模拟5000并发下2000个用户进行秒杀，会发现<code>mysql</code>报出<code>timeout</code>错误，同时<code>seckill_goods</code>表<code>amount</code>字段变成负数，<code>orders</code>表中同样产生了多于200的记录（具体数据不同环境下会有差异），这就代表产生了超卖，跟秒杀规则不符</li><li>模拟10000并发下单个用户进行秒杀，<code>orders</code>表中产生了多于1条的记录（具体数据不同环境下会有差异），这就说明一个用户针对这次活动买了多次，跟秒杀规则不符</li></ul><p>分析下代码会发现这其中的问题：</p><ul><li><p>步骤2，判断此产品是否加入了抢购   </p><p>  直接在<code>mysql</code>中查询，因为是在秒杀场景下，并发会很高，大量的请求到数据库，显然mysql是扛不住的，毕竟<code>mysql</code>每秒只能支撑千级别的并发请求</p></li><li><p>步骤7，判断登录用户是否已抢到   </p><p>  在高并发下同一个用户上个订单还没有生成成功，再次判断是否抢到依然会判断为否，这种情况下代码并没有对扣减和下单操作做任何限制，因此就产生了单个用户购买多个产品的情况，跟一个用户针对这次活动只能购买一次的要求不符</p></li><li><p>步骤8，扣库存操作   </p><p>  假设同时有1000个请求，这1000个请求在步骤5判断产品是否秒杀完的时候查询到的库存都是200，因此这些请求都会执行步骤8扣减库存，那库存肯定会变成负数，也就是产生了超卖现象</p></li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>经过分析得到三个问题需要解决：</p><ol><li>秒杀数据需要支持高并发访问</li><li>一个用户针对这次活动只能购买一次的问题，也就是限购问题</li><li>减库存不能扣成负数，订单数不能超过设置的库存数，也就是超卖问题</li></ol><p><code>Redis</code>作为内存型数据库，本身高速处理请求的特性可以支持高并发。针对超卖，也就是库存扣减变负数情况，<code>Redis</code>可以提供<code>Lua</code>脚本保证原子性和分布式锁两个解决高并发下数据不一致的问题。针对一个用户只能购买一次的要求，<code>Redis</code>的分布式锁可以解决问题。<br>因此，可以尝试用Redis解决上述问题，具体操作：</p><ul><li><p>为了支撑大量高并发的库存查验请求，需要用<code>Redis</code>保存秒杀活动数据（即<code>seckill_goods</code>表数据），这样一来请求可以直接从<code>Redis</code>中读取库存并进行查询，完成查询之后如果还有库存余量，就直接从<code>Redis</code>中扣除库存</p></li><li><p>扣减库存操作在<code>Redis</code>中进行，但是因为<code>Redis</code>扣减这一操作是分为读和写两个步骤，也就是必须先读数据进行判断再执行减操作，因此如果对这两个操作没有做好控制，就导致数据被改错，依然会出现超卖现象，为了保证并发访问的正确性需要使用原子操作解决问题，<code>Redis</code>提供了使用<code>Lua</code>脚本包含多个操作来实现原子性的方案<br>以下是<code>Redis</code>官方文档对<code>Lua</code>脚本原子性的解释</p><blockquote><p>Atomicity of scripts<br>  Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</p></blockquote></li><li><p>使用<code>Redis</code>实现分布式锁，对扣库存和写订单操作进行加锁，以保证一个用户只能购买一次的问题。</p></li></ul><h3 id="接入Redis"><a href="#接入Redis" class="headerlink" title="接入Redis"></a>接入Redis</h3><p>首先，不再使用<code>seckill_goods</code>表，新增秒杀活动逻辑变为在<code>Redis</code>中插入数据，类型为<code>hash</code>类型，<code>key</code>规则为<code>seckill_good_ + 产品id</code>，现在假设新增一条<code>key</code>为<code>seckill_good_1</code>的记录，值为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">amount</span>: <span class="number">200</span>,</span><br><span class="line">    <span class="attr">start_time</span>: <span class="string">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class="line">    <span class="attr">end_time</span>: <span class="string">&#x27;2023-06-20 00:00:00&#x27;</span>,</span><br><span class="line">    <span class="attr">is_valid</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">comment</span>: <span class="string">&#x27;...&#x27;</span>,</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>其次，创建<code>lua</code>脚本保证扣减操作的原子性，脚本内容如下</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redis.call(<span class="string">&#x27;hexists&#x27;</span>, KEYS[<span class="number">1</span>], KEYS[<span class="number">2</span>]) == <span class="number">1</span>) <span class="keyword">then</span></span><br><span class="line">  <span class="keyword">local</span> stock = <span class="built_in">tonumber</span>(redis.call(<span class="string">&#x27;hget&#x27;</span>, KEYS[<span class="number">1</span>], KEYS[<span class="number">2</span>]));</span><br><span class="line">  <span class="keyword">if</span> (stock &gt; <span class="number">0</span>) <span class="keyword">then</span></span><br><span class="line">    redis.call(<span class="string">&#x27;hincrby&#x27;</span>,  KEYS[<span class="number">1</span>], KEYS[<span class="number">2</span>], <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> stock</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>最后，完成代码，完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入相关库</span></span><br><span class="line"><span class="keyword">const</span> moment = <span class="built_in">require</span>(<span class="string">&#x27;moment&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> Op = <span class="built_in">require</span>(<span class="string">&#x27;sequelize&#x27;</span>).Op;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">v4</span>: uuidv4 &#125; = <span class="built_in">require</span>(<span class="string">&#x27;uuid&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入数据库model文件</span></span><br><span class="line"><span class="keyword">const</span> seckillModel = <span class="built_in">require</span>(<span class="string">&#x27;../../dbs/mysql/models/seckill_goods&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> ordersModel = <span class="built_in">require</span>(<span class="string">&#x27;../../dbs/mysql/models/orders&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入Redis实例</span></span><br><span class="line"><span class="keyword">const</span> redis = <span class="built_in">require</span>(<span class="string">&#x27;../../dbs/redis&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入工具函数或工具类</span></span><br><span class="line"><span class="keyword">const</span> UserModule = <span class="built_in">require</span>(<span class="string">&#x27;../modules/user&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; randomString, checkObjNull &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../utils/tools/funcs&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入秒杀key前缀</span></span><br><span class="line"><span class="keyword">const</span> &#123; SECKILL_GOOD, LOCK_KEY &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../utils/constants/redis-prefixs&#x27;</span>);</span><br><span class="line"><span class="comment">// 引入避免超卖lua脚本</span></span><br><span class="line"><span class="keyword">const</span> &#123; stock, lock, unlock &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../../utils/scripts&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seckill</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="function"><span class="title">doSeckill</span>(<span class="params">ctx, next</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> body = ctx.request.body;</span><br><span class="line">    <span class="keyword">const</span> goodId = ctx.params.good_id;</span><br><span class="line">    <span class="keyword">const</span> accessToken = ctx.query.accessToken;</span><br><span class="line">    <span class="keyword">const</span> path = body.path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基本参数校验</span></span><br><span class="line">    <span class="keyword">if</span> (!accessToken || !path) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">20001</span>, <span class="string">&#x27;参数错误！&#x27;</span>); &#125;;</span><br><span class="line">    <span class="comment">// 判断此产品是否加入了抢购</span></span><br><span class="line">    <span class="keyword">const</span> key = <span class="string">`<span class="subst">$&#123;SECKILL_GOOD&#125;</span><span class="subst">$&#123;goodId&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">const</span> seckill = <span class="keyword">await</span> redis.hgetall(key);</span><br><span class="line">    <span class="keyword">if</span> (!checkObjNull(seckill)) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30002</span>, <span class="string">&#x27;该产品并未有抢购活动！&#x27;</span>); &#125;;</span><br><span class="line">    <span class="comment">// 判断是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!seckill.is_valid) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30003</span>, <span class="string">&#x27;该活动已结束！&#x27;</span>); &#125;;</span><br><span class="line">    <span class="comment">// 判单是否开始、结束</span></span><br><span class="line">    <span class="keyword">if</span>(moment().isBefore(moment(seckill.start_time))) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.throwException(<span class="number">30004</span>, <span class="string">&#x27;该抢购活动还未开始！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(moment().isAfter(moment(seckill.end_time))) &#123;</span><br><span class="line">      <span class="keyword">return</span> ctx.throwException(<span class="number">30005</span>, <span class="string">&#x27;该抢购活动已经结束！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断是否卖完</span></span><br><span class="line">    <span class="keyword">if</span>(seckill.amount &lt; <span class="number">1</span>) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30006</span>, <span class="string">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的登录注册校验流程)</span></span><br><span class="line">    <span class="keyword">const</span> userInfo = <span class="keyword">await</span> UserModule.getUserInfo(accessToken);</span><br><span class="line">    <span class="keyword">if</span> (!userInfo) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">10002</span>, <span class="string">&#x27;用户不存在！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断登录用户是否已抢到</span></span><br><span class="line">    <span class="keyword">const</span> orderInfo = <span class="keyword">await</span> ordersModel.findOne(&#123;</span><br><span class="line">      <span class="attr">where</span>: &#123;</span><br><span class="line">        <span class="attr">user_id</span>: userInfo.id,</span><br><span class="line">        <span class="attr">good_id</span>: goodId,</span><br><span class="line">        <span class="attr">status</span>: &#123; [Op.between]: [<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>] &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (orderInfo) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30007</span>, <span class="string">&#x27;该用户已抢到该产品，无需再抢！&#x27;</span>); &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加锁，实现一个用户针对这次活动只能购买一次</span></span><br><span class="line">    <span class="keyword">const</span> lockKey = <span class="string">`<span class="subst">$&#123;LOCK_KEY&#125;</span><span class="subst">$&#123;userInfo.id&#125;</span>:<span class="subst">$&#123;goodId&#125;</span>`</span>; <span class="comment">// 锁的key有用户id和商品id组成</span></span><br><span class="line">    <span class="keyword">const</span> uuid = uuidv4();</span><br><span class="line">    <span class="keyword">const</span> expireTime = moment(seckill.end_time).diff(moment(), <span class="string">&#x27;minutes&#x27;</span>); <span class="comment">// 锁存在时间为当前时间和活动结束的时间差</span></span><br><span class="line">    <span class="keyword">const</span> tryLock = <span class="keyword">await</span> redis.eval(lock, <span class="number">2</span>, [lockKey, <span class="string">&#x27;releaseTime&#x27;</span>, uuid, expireTime]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (tryLock === <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 扣库存</span></span><br><span class="line">        <span class="keyword">const</span> count = <span class="keyword">await</span> redis.eval(stock, <span class="number">2</span>, [key, <span class="string">&#x27;amount&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30006</span>, <span class="string">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下单</span></span><br><span class="line">        <span class="keyword">const</span> orderData = &#123;</span><br><span class="line">          <span class="attr">order_no</span>: <span class="built_in">Date</span>.now() + randomString(<span class="number">4</span>), <span class="comment">// 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 </span></span><br><span class="line">          <span class="attr">good_id</span>: goodId,</span><br><span class="line">          <span class="attr">user_id</span>: userInfo.id,</span><br><span class="line">          <span class="attr">status</span>: <span class="string">&#x27;1&#x27;</span>, <span class="comment">// -1 已取消, 0 未付款， 1 已付款， 2已退款</span></span><br><span class="line">          <span class="attr">order_type</span>: <span class="string">&#x27;2&#x27;</span>, <span class="comment">// 1 常规订单 2 秒杀订单</span></span><br><span class="line">          <span class="comment">// seckill_id: seckill.id, // 秒杀活动id, redis中不维护秒杀活动id</span></span><br><span class="line">          <span class="attr">comment</span>: <span class="string">&#x27;&#x27;</span>, <span class="comment">// 备注</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">const</span> order = ordersModel.create(orderData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!order) &#123; <span class="keyword">return</span> ctx.throwException(<span class="number">30008</span>, <span class="string">&#x27;抢购失败!&#x27;</span>); &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">await</span> redis.eval(unlock, <span class="number">1</span>, [lockKey, uuid]);</span><br><span class="line">      <span class="keyword">return</span> ctx.throwException(<span class="number">30006</span>, <span class="string">&#x27;该产品已经卖完了！&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ctx.send(&#123;</span><br><span class="line">      path,</span><br><span class="line">      <span class="attr">data</span>: <span class="string">&#x27;抢购成功!&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="keyword">new</span> Seckill();</span><br></pre></td></tr></table></figure><p>这里代码主要做个四个修改：</p><ol><li>步骤2，判断产品是否加入了抢购，改为去<code>Redis</code>中查询</li><li>步骤7，判断登录用户是否已抢到，因为不在维护抢购活动<code>id</code>，所以改为使用用户<code>id</code>、产品<code>id</code>和状态<code>status</code>判断</li><li>步骤8，扣库存，改为使用<code>lua</code>脚本去<code>Redis</code>中扣库存</li><li>对扣库存和写入数据库操作进行加锁</li></ol><p>订单的操作仍然在<code>Mysql</code>数据库中进行，因为大部分的请求都在步骤5被拦截了，剩余请求<code>Mysql</code>是完全有能力处理的。   </p><p>再次通过<code>Jmeter</code>进行测试，发现订单表正常，库存量扣减正常，说明超卖问题和限购已经解决。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><ol><li>秒杀场景的其他技术<br> 基于<code>Redis</code>支持高并发、键值对型数据库和支持原子操作等特点，案例中使用<code>Redis</code>来作为秒杀应对方案。在更复杂的秒杀场景下，除了使用<code>Redis</code>外，在必要的的情况下还需要用到其他一些技术：<ul><li>限流，用漏斗算法、令牌桶算法等进行限流</li><li>缓存，把热点数据缓存到内存里，尽可能缓解数据库访问的压力</li><li>削峰，使用消息队列和缓存技术使瞬间高流量转变成一段时间的平稳流量，比如客户抢购成功后，立即返回响应，然后通过消息队列异步处理后续步骤，发短信，写日志，更新一致性低的数据库等等</li><li>异步，假设商家创建一个只针对粉丝的秒杀活动，如果商家的粉丝比较少（假设小于1000），那么秒杀活动直接推送给所有粉丝，如果用户粉丝比较多，程序立刻推送给排名前1000的用户，其余用户采用消息队列延迟推送。（1000这个数字需要根据具体情况决定，比如粉丝数2000以内的商家占99%，只有1%的用户粉丝超过2000，那么这个值就应该设置为2000）</li><li>分流，单台服务器不行就上集群，通过负载均衡共同去处理请求，分散压力</li></ul> 这些技术的应用会让整个秒杀系统更加完善，但是核心技术还是<code>Redis</code>，可以说用好<code>Redis</code>实现的秒杀系统就足以应对大部分场景。</li><li><code>Redis</code>健壮性<br> 案例使用的是单机版<code>Redis</code>，单节点在生产环境基本上不会使用，因为<ul><li>不能达到高可用</li><li>即便有着<code>AOF</code>日志和<code>RDB</code>快照的解决方案以保证数据不丢失，但都只能放在<code>master</code>上，一旦机器故障，服务就无法运行，而且即便采取了相应措施仍不可避免的会造成数据丢失。</li></ul> 因此，<code>Redis</code>的主从机制和集群机制在生产环境下是必须的。</li><li><code>Redis</code>分布式锁的问题<ul><li>单点分布式锁，案例提到的分布式锁，实际上更准确的说法是单点分布式锁，是为了方便演示，但是，单点<code>Redis</code>分布式锁是肯定不能用在生产环境的，理由跟第2点类似</li><li>以主从机制（多机器）为基础的分布式锁，也是不够的，因为<code>redis</code>在进行主从复制时是异步完成的，比如在<code>clientA</code>获取锁后，主<code>redis</code>复制数据到从<code>redis</code>过程中崩溃了，导致锁没有复制到从<code>redis</code>中，然后从<code>redis</code>选举出一个升级为主<code>redis</code>，造成新的主<code>redis</code>没有<code>clientA</code>设置的锁，这时<code>clientB</code>尝试获取锁，并且能够成功获取锁，导致互斥失效。</li></ul> 针对以上问题，<code>redis</code>官方设计了<code>Redlock</code>，在<code>Node.js</code>环境下对应的资源库为<code>node-redlock</code>，可以用<code>npm</code>安装，至少需要3个独立的服务器或集群才能使用，提供了非常高的容错率，在生产环境中应该优先采用此方案部署。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>秒杀场景的特点可以总结为瞬时并发访问、读多写少、限时和限量，开发中还要考虑避免超卖现象以及类似黄牛抢票的限购问题，针对以上特点和问题，分析得到开发的原则是：数据写入内存而不是写入硬盘，异步处理而不是同步处理，扣库存操作原子执行以及对单用户购买进行加锁，而<code>Redis</code>正好是符合以上全部特点的工具，因此最终选择<code>Redis</code>来解决问题。</p><p>秒杀场景是一个在电商业务中相对复杂的场景，此篇文章只是介绍了其中最核心的逻辑，实际业务可能更加复杂，但只需要在此核心基础上进行扩展和优化即可。<br>秒杀场景的解决方案不仅仅适合秒杀，类似的还有抢红包、抢优惠券以及抢票等等，思路都是一致的。<br>解决方案的思路还可以应用在单独限购、第二件半价以及控制库存等等诸多场景，大家要灵活运用。</p><h2 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h2><p><a href="https://github.com/threerocks/redis-seckill">https://github.com/threerocks/redis-seckill</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://time.geekbang.org/column/article/307421">https://time.geekbang.org/column/article/307421</a><br><a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Node.js </tag>
            
            <tag> Javascript </tag>
            
            <tag> Mysql </tag>
            
            <tag> Redis </tag>
            
            <tag> 秒杀 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
