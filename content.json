{"meta":{"title":"刘小磊的技术博客","subtitle":"","description":"","author":"刘小磊","url":"https://threerocks.github.io","root":"/"},"pages":[{"title":"about","date":"2021-06-25T08:43:56.000Z","updated":"2021-06-25T08:49:31.000Z","comments":true,"path":"about/index.html","permalink":"https://threerocks.github.io/about/index.html","excerpt":"","text":"asdjasdk"}],"posts":[{"title":"Promise知识汇总以及面试情况","slug":"Promise知识汇总以及面试情况","date":"2021-06-25T09:59:29.000Z","updated":"2021-06-25T10:10:12.000Z","comments":true,"path":"2021/06/25/Promise知识汇总以及面试情况/","link":"","permalink":"https://threerocks.github.io/2021/06/25/Promise%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB%E4%BB%A5%E5%8F%8A%E9%9D%A2%E8%AF%95%E6%83%85%E5%86%B5/","excerpt":"写在前面Javascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 Promise/A+ 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。 关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。","text":"写在前面Javascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 Promise/A+ 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。 关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。 实现Promise规范解读Promise/A+规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版Promise/A+标准。 1、Promise有三种状态pending，fulfilled和rejected。（为了一致性，此文章称fulfilled状态为resolved状态） 状态转换只能是pending到resolved或者pending到rejected； 状态一旦转换完成，不能再次转换。 2、Promise拥有一个then方法，用以处理resolved或rejected状态下的值。 then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。 then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise） onResolved/onRejected有返回值则把返回值定义为x，并执行[[Resolve]](promise2, x); onResolved/onRejected运行出错，则把promise2设置为rejected状态； onResolved/onRejected不是函数，则需要把promise1的状态传递下去。 3、不同的Promise实现可以的交互。 规范中称这一步操作为Promise解决过程，函数标示为[[Resolve]](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。 [[Resolve]](promise, x)函数具体运行规则： 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise; 如果 x 为 Promise ，则使 promise 接受 x 的状态; 如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入rejected状态，如果then不是函数，同样让promise进入rejected状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用[[Resolve]](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入rejected状态； 如果 x 不是对象或者函数，直接就用x的值来执行promise。 代码实现规范解读第1条，代码实现： 123456789101112131415161718192021222324252627class Promise &#123; // 定义Promise状态变量，初始值为pending status = &#x27;pending&#x27;; // 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值 data = &#x27;&#x27;; // Promise构造函数，传入参数为一个可执行的函数 constructor(executor) &#123; // resolve函数负责把状态转换为resolved function resolve(value) &#123; this.status = &#x27;resolved&#x27;; this.data = value; &#125; // reject函数负责把状态转换为rejected function reject(reason) &#123; this.status = &#x27;rejected&#x27;; this.data = reason; &#125; // 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject try &#123; executor(resolve, reject); &#125; catch(e) &#123; reject(e) &#125; &#125;&#125; 规范解读第2条，代码实现： 12345678910111213141516171819202122232425262728293031323334353637/** * 拥有一个then方法 * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected * 返回一个新的Promise*/then(onResolved, onRejected) &#123; // 设置then的默认参数，默认参数实现Promise的值的穿透 onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : function(v) &#123; return e &#125;; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function(e) &#123; throw e &#125;; let promise2; promise2 = new Promise((resolve, reject) =&gt; &#123; // 如果状态为resolved，则执行onResolved if (this.status === &#x27;resolved&#x27;) &#123; try &#123; // onResolved/onRejected有返回值则把返回值定义为x const x = onResolved(this.data); // 执行[[Resolve]](promise2, x) resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; // 如果状态为rejected，则执行onRejected if (this.status === &#x27;rejected&#x27;) &#123; try &#123; const x = onRejected(this.data); resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125; &#125;); return promise2;&#125; 现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下 resolvePromise未定义； then方法执行的时候，promise可能仍然处于pending状态，因为executor中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机； onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的) 解决办法： 根据规范解读第3条，定义并实现resolvePromise函数； then方法执行时如果promise仍然处于pending状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。 Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐这篇文章。 好了，有了解决办法，我们就把代码进一步完善： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110class Promise &#123; // 定义Promise状态变量，初始值为pending status = &#x27;pending&#x27;; // 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值 data = &#x27;&#x27;; // Promise resolve时的回调函数集 onResolvedCallback = []; // Promise reject时的回调函数集 onRejectedCallback = []; // Promise构造函数，传入参数为一个可执行的函数 constructor(executor) &#123; // resolve函数负责把状态转换为resolved function resolve(value) &#123; this.status = &#x27;resolved&#x27;; this.data = value; for (const func of this.onResolvedCallback) &#123; func(this.data); &#125; &#125; // reject函数负责把状态转换为rejected function reject(reason) &#123; this.status = &#x27;rejected&#x27;; this.data = reason; for (const func of this.onRejectedCallback) &#123; func(this.data); &#125; &#125; // 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject try &#123; executor(resolve, reject); &#125; catch(e) &#123; reject(e) &#125; &#125; /** * 拥有一个then方法 * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected * 返回一个新的Promise */ then(onResolved, onRejected) &#123; // 设置then的默认参数，默认参数实现Promise的值的穿透 onResolved = typeof onResolved === &#x27;function&#x27; ? onResolved : function(v) &#123; return e &#125;; onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : function(e) &#123; throw e &#125;; let promise2; promise2 = new Promise((resolve, reject) =&gt; &#123; // 如果状态为resolved，则执行onResolved if (this.status === &#x27;resolved&#x27;) &#123; setTimeout(() =&gt; &#123; try &#123; // onResolved/onRejected有返回值则把返回值定义为x const x = onResolved(this.data); // 执行[[Resolve]](promise2, x) this.resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; // 如果状态为rejected，则执行onRejected if (this.status === &#x27;rejected&#x27;) &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.data); this.resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125; // 如果状态为pending，则把处理函数进行存储 if (this.status = &#x27;pending&#x27;) &#123; this.onResolvedCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onResolved(this.data); this.resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); this.onRejectedCallback.push(() =&gt; &#123; setTimeout(() =&gt; &#123; try &#123; const x = onRejected(this.data); this.resolvePromise(promise2, x, resolve, reject); &#125; catch (e) &#123; reject(e); &#125; &#125;, 0); &#125;); &#125; &#125;); return promise2; &#125; // [[Resolve]](promise2, x)函数 resolvePromise(promise2, x, resolve, reject) &#123; &#125; &#125; 至此，规范中关于then的部分就全部实现完毕了。 规范解读第3条，代码实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// [[Resolve]](promise2, x)函数 resolvePromise(promise2, x, resolve, reject) &#123; let called = false; if (promise2 === x) &#123; return reject(new TypeError(&#x27;Chaining cycle detected for promise!&#x27;)) &#125; // 如果x仍然为Promise的情况 if (x instanceof Promise) &#123; // 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise if (x.status === &#x27;pending&#x27;) &#123; x.then(function(value) &#123; resolvePromise(promise2, value, resolve, reject) &#125;, reject) &#125; else &#123; // 如果x状态已经确定了，直接取它的状态 x.then(resolve, reject) &#125; return &#125; if (x !== null &amp;&amp; (Object.prototype.toString(x) === &#x27;[object Object]&#x27; || Object.prototype.toString(x) === &#x27;[object Function]&#x27;)) &#123; try &#123; // 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制 const then = x.then // then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值 if (typeof then === &#x27;function&#x27;) &#123; then.call(x, (y) =&gt; &#123; if (called) return; called = true; this.resolvePromise(promise2, y, resolve, reject); &#125;, (r) =&gt; &#123; if (called) return; called = true; reject(r); &#125;) &#125; else &#123; // 如果then不是函数，那就说明x不是thenable，直接resolve x if (called) return ; called = true; resolve(x); &#125; &#125; catch (e) &#123; if (called) return; called = true; reject(e); &#125; &#125; else &#123; resolve(x); &#125; &#125; 这一步骤非常简单，只要按照规范转换成代码即可。 最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。 Promise其他方法实现1、catch方法catch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。 123catch(onRejected) &#123; return this.then(null, onRejected);&#125; 2、done方法catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。 123456done() &#123; this.catch(reason =&gt; &#123; console.log(&#x27;done&#x27;, reason); throw reason; &#125;);&#125; 3、finally方法finally方法用于无论是resolve还是reject，finally的参数函数都会被执行。 123456789finally(fn) &#123; return this.then(value =&gt; &#123; fn(); return value; &#125;, reason =&gt; &#123; fn(); throw reason; &#125;);&#125;; 4、Promise.all方法Promise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为resolved时，promise2状态为resolved并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。 123456789101112131415static all(promiseList) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = []; let i = 0; for (const p of promiseList) &#123; p.then(value =&gt; &#123; result[i] = value; if (result.length === promiseList.length) &#123; resolve(result); &#125; &#125;, reject); i++; &#125; &#125;);&#125; 5、Promise.race方法Promise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。 123456789static race(promiseList) &#123; return new Promise((resolve, reject) =&gt; &#123; for (const p of promiseList) &#123; p.then((value) =&gt; &#123; resolve(value); &#125;, reject); &#125; &#125;);&#125; 6、Promise.resolve方法/Promise.rejectPromise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。 123456789101112131415static resolve(value) &#123; let promise; promise = new Promise((resolve, reject) =&gt; &#123; this.resolvePromise(promise, value, resolve, reject); &#125;); return promise;&#125;static reject(reason) &#123; return new Promise((resolve, reject) =&gt; &#123; reject(reason); &#125;);&#125; 常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。 Promise面试相关面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。Promise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。 简单介绍下Promise。Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的） 提问概率：99% 评分标准：人性化判断即可，此问题一般作为引入问题。 加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。 实现一个简单的，支持异步链式调用的Promise类。这个答案不是固定的，可以参考最简实现 Promise，支持异步链式调用 提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识） 加分项：onResolved/onRejected函数异步调用，错误捕获合理等 Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)JS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）Event Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）浏览器运行机制可参考这篇文章 提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解） 加分项：扩展讲述浏览器运行机制。 阐述Promise的一些方法。Promise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等 提问概率：25% 加分项：越多越好 Promise存在哪些缺点。1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。 提问概率：25%（此问题作为提高题目，出现概率不高） 加分项：越多越合理越好 使用Promise进行顺序（sequence）处理。1、使用async函数配合await或者使用generator函数配合yield。2、使用promise.then通过for循环或者Array.prototype.reduce实现。 12345678910function sequenceTasks(tasks) &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); return tasks.reduce(function (promise, task) &#123; return promise.then(() =&gt; task).then(pushValue); &#125;, Promise.resolve());&#125; 提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用） 评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。 如何停止一个Promise链？在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。 123Promise.cancel = Promise.stop = function() &#123; return new Promise(function()&#123;&#125;)&#125; 提问概率：50%（此问题主要考察面试者罗辑思维） Promise链上返回的最后一个Promise出错了怎么办？catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。 123456done() &#123; this.catch(reason =&gt; &#123; console.log(&#x27;done&#x27;, reason); throw reason; &#125;);&#125; 提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度） 加分项：给出具体的done()方法代码 Promise存在哪些使用技巧或者最佳实践？1、链式Promise要返回一个Promise，而不只是构造一个Promise。2、合理的使用Promise.all和Promise.race等方法。3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。 提问概率：10%（出题概率极低的一个题目） 加分项：越多越好 参考链接：http://liubin.org/promises-bookhttps://github.com/xieranmaya/blog/issues/3https://segmentfault.com/a/1190000016550260","categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://threerocks.github.io/tags/Promise/"},{"name":"Node.js","slug":"Node-js","permalink":"https://threerocks.github.io/tags/Node-js/"},{"name":"Javascript","slug":"Javascript","permalink":"https://threerocks.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://threerocks.github.io/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://threerocks.github.io/tags/%E5%BC%82%E6%AD%A5/"}]},{"title":"Redis应用实战 - 秒杀场景（Node.js版本）","slug":"Redis应用实战 - 秒杀场景（Node.js版本）","date":"2021-06-25T09:07:25.000Z","updated":"2021-06-25T10:10:39.000Z","comments":true,"path":"2021/06/25/Redis应用实战 - 秒杀场景（Node.js版本）/","link":"","permalink":"https://threerocks.github.io/2021/06/25/Redis%E5%BA%94%E7%94%A8%E5%AE%9E%E6%88%98%20-%20%E7%A7%92%E6%9D%80%E5%9C%BA%E6%99%AF%EF%BC%88Node.js%E7%89%88%E6%9C%AC%EF%BC%89/","excerpt":"写在前面公司随着业务量的增加，最近用时几个月时间在项目中全面接入Redis，开发过程中发现市面上缺少具体的实战资料，尤其是在Node.js环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍Redis的几个使用场景，期望大家一起学习、进步。下面就开始第一篇，秒杀场景。 业务分析实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下： 秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用CDN或者是浏览器进行缓存。 秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是 短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高） 请求数量大于商品库存，比如10000个用户抢购，但是库存只有100 限定用户只能在一定时间段内购买 限制单个用户购买数量，避免刷单 抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数 对数据库的操作读多写少，而且读操作相对简单 秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。 根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。 开发环境数据库：Redis 3.2.9 + Mysql 5.7.18服务器：Node.js v10.15.0测试工具：Jmeter-5.4.1","text":"写在前面公司随着业务量的增加，最近用时几个月时间在项目中全面接入Redis，开发过程中发现市面上缺少具体的实战资料，尤其是在Node.js环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍Redis的几个使用场景，期望大家一起学习、进步。下面就开始第一篇，秒杀场景。 业务分析实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下： 秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用CDN或者是浏览器进行缓存。 秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是 短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高） 请求数量大于商品库存，比如10000个用户抢购，但是库存只有100 限定用户只能在一定时间段内购买 限制单个用户购买数量，避免刷单 抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数 对数据库的操作读多写少，而且读操作相对简单 秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。 根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。 开发环境数据库：Redis 3.2.9 + Mysql 5.7.18服务器：Node.js v10.15.0测试工具：Jmeter-5.4.1 实战数据库准备如图所示，Mysql中需要创建三张表，分别是 产品表，用于记录产品信息，字段分别为Id、名称、缩略图、价格和状态等等 秒杀活动表，用于记录秒杀活动的详细信息，字段分别为Id、参与秒杀的产品Id、库存量、秒杀开始时间、秒杀结束时间和秒杀活动是否有效等等 订单表，用于记录下单后的数据，字段分别为Id、订单号、产品Id、购买用户Id、订单状态、订单类型和秒杀活动Id等等 下面是创建sql语句，以供参考 123456789101112CREATE TABLE `scekill_goods` ( `id` INTEGER NOT NULL auto_increment, `fk_good_id` INTEGER, `amount` INTEGER, `start_time` DATETIME, `end_time` DATETIME, `is_valid` TINYINT ( 1 ), `comment` VARCHAR ( 255 ), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL,PRIMARY KEY ( `id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4; 12345678910111213CREATE TABLE `orders` ( `id` INTEGER NOT NULL auto_increment, `order_no` VARCHAR ( 255 ), `good_id` INTEGER, `user_id` INTEGER, `status` ENUM ( &#x27;-1&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27; ), `order_type` ENUM ( &#x27;1&#x27;, &#x27;2&#x27; ), `scekill_id` INTEGER, `comment` VARCHAR ( 255 ), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL,PRIMARY KEY ( `id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4; 1234567891011121314CREATE TABLE `goods` ( `id` INTEGER NOT NULL auto_increment, `name` VARCHAR ( 255 ), `thumbnail` VARCHAR ( 255 ), `price` INTEGER, `status` TINYINT ( 1 ), `stock` INTEGER, `stock_left` INTEGER, `description` VARCHAR ( 255 ), `comment` VARCHAR ( 255 ), `created_at` DATETIME NOT NULL, `updated_at` DATETIME NOT NULL,PRIMARY KEY ( `id` ) ) ENGINE = INNODB DEFAULT CHARSET = utf8mb4; 产品表在此次业务中不是重点，以下逻辑都以id=1的产品为示例，请悉知。秒杀活动表中创建一条库存为200的记录，作为秒杀测试数据，参考下面语句： 1234567891011121314151617181920212223INSERT INTO `redis_app`.`seckill_goods` ( `id`, `fk_good_id`, `amount`, `start_time`, `end_time`, `is_valid`, `comment`, `created_at`, `updated_at` )VALUES ( 1, 1, 200, &#x27;2020-06-20 00:00:00&#x27;, &#x27;2023-06-20 00:00:00&#x27;, 1, &#x27;...&#x27;, &#x27;2020-06-20 00:00:00&#x27;, &#x27;2021-06-22 10:18:16&#x27; ); 秒杀接口开发首先，说一下Node.js中的具体开发环境: web框架使用Koa2 mysql操作使用基于promise的Node.js ORM工具Sequelize redis操作使用ioredis库 封装ctx.throwException方法用于处理错误，封装ctx.send方法用于返回正确结果，具体实现参考文末完整代码 其次，分析一下接口要处理的逻辑，大概步骤和顺序如下： 基本参数校验 判断产品是否加入了抢购 判断秒杀活动是否有效 判断秒杀活动是否开始、结束 判断秒杀商品是否卖完 获取登录用户信息 判断登录用户是否已抢到 扣库存 下单 最后，根据分析把以上步骤用代码进行初步实现，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485// 引入moment库处理时间相关数据const moment = require(&#x27;moment&#x27;);// 引入数据库model文件const seckillModel = require(&#x27;../../dbs/mysql/models/seckill_goods&#x27;);const ordersModel = require(&#x27;../../dbs/mysql/models/orders&#x27;);// 引入工具函数或工具类const UserModule = require(&#x27;../modules/user&#x27;);const &#123; random_String &#125; = require(&#x27;../../utils/tools/funcs&#x27;);class Seckill &#123; /** * 秒杀接口 * * @method post * @param good_id 产品id * @param accessToken 用户Token * @param path 秒杀完成后跳转路径 */ async doSeckill(ctx, next) &#123; const body = ctx.request.body; const accessToken = ctx.query.accessToken; const path = body.path; // 基本参数校验 if (!accessToken || !path) &#123; return ctx.throwException(20001, &#x27;参数错误！&#x27;); &#125;; // 判断此产品是否加入了抢购 const seckill = await seckillModel.findOne(&#123; where: &#123; fk_good_id: ctx.params.good_id, &#125; &#125;); if (!seckill) &#123; return ctx.throwException(30002, &#x27;该产品并未有抢购活动！&#x27;); &#125;; // 判断是否有效 if (!seckill.is_valid) &#123; return ctx.throwException(30003, &#x27;该活动已结束！&#x27;); &#125;; // 判单是否开始、结束 if(moment().isBefore(moment(seckill.start_time))) &#123; return ctx.throwException(30004, &#x27;该抢购活动还未开始！&#x27;); &#125; if(moment().isAfter(moment(seckill.end_time))) &#123; return ctx.throwException(30005, &#x27;该抢购活动已经结束！&#x27;); &#125; // 判断是否卖完 if(seckill.amount &lt; 1) &#123; return ctx.throwException(30006, &#x27;该产品已经卖完了！&#x27;); &#125;; //获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的accessToken校验流程) const userInfo = await UserModule.getUserInfo(accessToken); if (!userInfo) &#123; return ctx.throwException(10002, &#x27;用户不存在！&#x27;); &#125;; // 判断登录用户是否已抢到（一个用户针对这次活动只能购买一次） const orderInfo = await ordersModel.findOne(&#123; where: &#123; user_id: userInfo.id, seckill_id: seckill.id, &#125;, &#125;); if (orderInfo) &#123; return ctx.throwException(30007, &#x27;该用户已抢到该产品，无需再抢！&#x27;); &#125;; // 扣库存 const count = await seckill.decrement(&#x27;amount&#x27;); if (count.amount &lt;= 0) &#123; return ctx.throwException(30006, &#x27;该产品已经卖完了！&#x27;); &#125;; // 下单 const orderData = &#123; order_no: Date.now() + random_String(4), // 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 good_id: ctx.params.good_id, user_id: userInfo.id, status: &#x27;1&#x27;, // -1 已取消, 0 未付款， 1 已付款， 2已退款 order_type: &#x27;2&#x27;, // 1 常规订单 2 秒杀订单 seckill_id: seckill.id, // 秒杀活动id comment: &#x27;&#x27;, // 备注 &#125;; const order = ordersModel.create(orderData); if (!order) &#123; return ctx.throwException(30008, &#x27;抢购失败!&#x27;); &#125;; ctx.send(&#123; path, data: &#x27;抢购成功!&#x27; &#125;); &#125;&#125;module.exports = new Seckill(); 至此，秒杀接口用传统的关系型数据库就实现完成了，代码并不复杂，注释也很详细，不用特别的讲解大家也都能看懂，那它能不能正常工作呢，答案显然是否定的通过Jmeter模拟以下测试： 模拟5000并发下2000个用户进行秒杀，会发现mysql报出timeout错误，同时seckill_goods表amount字段变成负数，orders表中同样产生了多于200的记录（具体数据不同环境下会有差异），这就代表产生了超卖，跟秒杀规则不符 模拟10000并发下单个用户进行秒杀，orders表中产生了多于1条的记录（具体数据不同环境下会有差异），这就说明一个用户针对这次活动买了多次，跟秒杀规则不符 分析下代码会发现这其中的问题： 步骤2，判断此产品是否加入了抢购 直接在mysql中查询，因为是在秒杀场景下，并发会很高，大量的请求到数据库，显然mysql是扛不住的，毕竟mysql每秒只能支撑千级别的并发请求 步骤7，判断登录用户是否已抢到 在高并发下同一个用户上个订单还没有生成成功，再次判断是否抢到依然会判断为否，这种情况下代码并没有对扣减和下单操作做任何限制，因此就产生了单个用户购买多个产品的情况，跟一个用户针对这次活动只能购买一次的要求不符 步骤8，扣库存操作 假设同时有1000个请求，这1000个请求在步骤5判断产品是否秒杀完的时候查询到的库存都是200，因此这些请求都会执行步骤8扣减库存，那库存肯定会变成负数，也就是产生了超卖现象 解决方案经过分析得到三个问题需要解决： 秒杀数据需要支持高并发访问 一个用户针对这次活动只能购买一次的问题，也就是限购问题 减库存不能扣成负数，订单数不能超过设置的库存数，也就是超卖问题 Redis作为内存型数据库，本身高速处理请求的特性可以支持高并发。针对超卖，也就是库存扣减变负数情况，Redis可以提供Lua脚本保证原子性和分布式锁两个解决高并发下数据不一致的问题。针对一个用户只能购买一次的要求，Redis的分布式锁可以解决问题。因此，可以尝试用Redis解决上述问题，具体操作： 为了支撑大量高并发的库存查验请求，需要用Redis保存秒杀活动数据（即seckill_goods表数据），这样一来请求可以直接从Redis中读取库存并进行查询，完成查询之后如果还有库存余量，就直接从Redis中扣除库存 扣减库存操作在Redis中进行，但是因为Redis扣减这一操作是分为读和写两个步骤，也就是必须先读数据进行判断再执行减操作，因此如果对这两个操作没有做好控制，就导致数据被改错，依然会出现超卖现象，为了保证并发访问的正确性需要使用原子操作解决问题，Redis提供了使用Lua脚本包含多个操作来实现原子性的方案以下是Redis官方文档对Lua脚本原子性的解释 Atomicity of scripts Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed. 使用Redis实现分布式锁，对扣库存和写订单操作进行加锁，以保证一个用户只能购买一次的问题。 接入Redis首先，不再使用seckill_goods表，新增秒杀活动逻辑变为在Redis中插入数据，类型为hash类型，key规则为seckill_good_ + 产品id，现在假设新增一条key为seckill_good_1的记录，值为 1234567&#123; amount: 200, start_time: &#x27;2020-06-20 00:00:00&#x27;, end_time: &#x27;2023-06-20 00:00:00&#x27;, is_valid: 1, comment: &#x27;...&#x27;, &#125; 其次，创建lua脚本保证扣减操作的原子性，脚本内容如下 12345678if (redis.call(&#x27;hexists&#x27;, KEYS[1], KEYS[2]) == 1) then local stock = tonumber(redis.call(&#x27;hget&#x27;, KEYS[1], KEYS[2])); if (stock &gt; 0) then redis.call(&#x27;hincrby&#x27;, KEYS[1], KEYS[2], -1); return stock end; return 0end; 最后，完成代码，完整代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596// 引入相关库const moment = require(&#x27;moment&#x27;);const Op = require(&#x27;sequelize&#x27;).Op;const &#123; v4: uuidv4 &#125; = require(&#x27;uuid&#x27;);// 引入数据库model文件const seckillModel = require(&#x27;../../dbs/mysql/models/seckill_goods&#x27;);const ordersModel = require(&#x27;../../dbs/mysql/models/orders&#x27;);// 引入Redis实例const redis = require(&#x27;../../dbs/redis&#x27;);// 引入工具函数或工具类const UserModule = require(&#x27;../modules/user&#x27;);const &#123; randomString, checkObjNull &#125; = require(&#x27;../../utils/tools/funcs&#x27;);// 引入秒杀key前缀const &#123; SECKILL_GOOD, LOCK_KEY &#125; = require(&#x27;../../utils/constants/redis-prefixs&#x27;);// 引入避免超卖lua脚本const &#123; stock, lock, unlock &#125; = require(&#x27;../../utils/scripts&#x27;);class Seckill &#123; async doSeckill(ctx, next) &#123; const body = ctx.request.body; const goodId = ctx.params.good_id; const accessToken = ctx.query.accessToken; const path = body.path; // 基本参数校验 if (!accessToken || !path) &#123; return ctx.throwException(20001, &#x27;参数错误！&#x27;); &#125;; // 判断此产品是否加入了抢购 const key = `$&#123;SECKILL_GOOD&#125;$&#123;goodId&#125;`; const seckill = await redis.hgetall(key); if (!checkObjNull(seckill)) &#123; return ctx.throwException(30002, &#x27;该产品并未有抢购活动！&#x27;); &#125;; // 判断是否有效 if (!seckill.is_valid) &#123; return ctx.throwException(30003, &#x27;该活动已结束！&#x27;); &#125;; // 判单是否开始、结束 if(moment().isBefore(moment(seckill.start_time))) &#123; return ctx.throwException(30004, &#x27;该抢购活动还未开始！&#x27;); &#125; if(moment().isAfter(moment(seckill.end_time))) &#123; return ctx.throwException(30005, &#x27;该抢购活动已经结束！&#x27;); &#125; // 判断是否卖完 if(seckill.amount &lt; 1) &#123; return ctx.throwException(30006, &#x27;该产品已经卖完了！&#x27;); &#125;; //获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的登录注册校验流程) const userInfo = await UserModule.getUserInfo(accessToken); if (!userInfo) &#123; return ctx.throwException(10002, &#x27;用户不存在！&#x27;); &#125;; // 判断登录用户是否已抢到 const orderInfo = await ordersModel.findOne(&#123; where: &#123; user_id: userInfo.id, good_id: goodId, status: &#123; [Op.between]: [&#x27;0&#x27;, &#x27;1&#x27;] &#125;, &#125;, &#125;); if (orderInfo) &#123; return ctx.throwException(30007, &#x27;该用户已抢到该产品，无需再抢！&#x27;); &#125;; // 加锁，实现一个用户针对这次活动只能购买一次 const lockKey = `$&#123;LOCK_KEY&#125;$&#123;userInfo.id&#125;:$&#123;goodId&#125;`; // 锁的key有用户id和商品id组成 const uuid = uuidv4(); const expireTime = moment(seckill.end_time).diff(moment(), &#x27;minutes&#x27;); // 锁存在时间为当前时间和活动结束的时间差 const tryLock = await redis.eval(lock, 2, [lockKey, &#x27;releaseTime&#x27;, uuid, expireTime]); try &#123; if (tryLock === 1) &#123; // 扣库存 const count = await redis.eval(stock, 2, [key, &#x27;amount&#x27;, &#x27;&#x27;, &#x27;&#x27;]); if (count &lt;= 0) &#123; return ctx.throwException(30006, &#x27;该产品已经卖完了！&#x27;); &#125;; // 下单 const orderData = &#123; order_no: Date.now() + randomString(4), // 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 good_id: goodId, user_id: userInfo.id, status: &#x27;1&#x27;, // -1 已取消, 0 未付款， 1 已付款， 2已退款 order_type: &#x27;2&#x27;, // 1 常规订单 2 秒杀订单 // seckill_id: seckill.id, // 秒杀活动id, redis中不维护秒杀活动id comment: &#x27;&#x27;, // 备注 &#125;; const order = ordersModel.create(orderData); if (!order) &#123; return ctx.throwException(30008, &#x27;抢购失败!&#x27;); &#125;; &#125; &#125; catch (e) &#123; await redis.eval(unlock, 1, [lockKey, uuid]); return ctx.throwException(30006, &#x27;该产品已经卖完了！&#x27;); &#125; ctx.send(&#123; path, data: &#x27;抢购成功!&#x27; &#125;); &#125;&#125;module.exports = new Seckill(); 这里代码主要做个四个修改： 步骤2，判断产品是否加入了抢购，改为去Redis中查询 步骤7，判断登录用户是否已抢到，因为不在维护抢购活动id，所以改为使用用户id、产品id和状态status判断 步骤8，扣库存，改为使用lua脚本去Redis中扣库存 对扣库存和写入数据库操作进行加锁 订单的操作仍然在Mysql数据库中进行，因为大部分的请求都在步骤5被拦截了，剩余请求Mysql是完全有能力处理的。 再次通过Jmeter进行测试，发现订单表正常，库存量扣减正常，说明超卖问题和限购已经解决。 其他问题 秒杀场景的其他技术 基于Redis支持高并发、键值对型数据库和支持原子操作等特点，案例中使用Redis来作为秒杀应对方案。在更复杂的秒杀场景下，除了使用Redis外，在必要的的情况下还需要用到其他一些技术： 限流，用漏斗算法、令牌桶算法等进行限流 缓存，把热点数据缓存到内存里，尽可能缓解数据库访问的压力 削峰，使用消息队列和缓存技术使瞬间高流量转变成一段时间的平稳流量，比如客户抢购成功后，立即返回响应，然后通过消息队列异步处理后续步骤，发短信，写日志，更新一致性低的数据库等等 异步，假设商家创建一个只针对粉丝的秒杀活动，如果商家的粉丝比较少（假设小于1000），那么秒杀活动直接推送给所有粉丝，如果用户粉丝比较多，程序立刻推送给排名前1000的用户，其余用户采用消息队列延迟推送。（1000这个数字需要根据具体情况决定，比如粉丝数2000以内的商家占99%，只有1%的用户粉丝超过2000，那么这个值就应该设置为2000） 分流，单台服务器不行就上集群，通过负载均衡共同去处理请求，分散压力 这些技术的应用会让整个秒杀系统更加完善，但是核心技术还是Redis，可以说用好Redis实现的秒杀系统就足以应对大部分场景。 Redis健壮性 案例使用的是单机版Redis，单节点在生产环境基本上不会使用，因为 不能达到高可用 即便有着AOF日志和RDB快照的解决方案以保证数据不丢失，但都只能放在master上，一旦机器故障，服务就无法运行，而且即便采取了相应措施仍不可避免的会造成数据丢失。 因此，Redis的主从机制和集群机制在生产环境下是必须的。 Redis分布式锁的问题 单点分布式锁，案例提到的分布式锁，实际上更准确的说法是单点分布式锁，是为了方便演示，但是，单点Redis分布式锁是肯定不能用在生产环境的，理由跟第2点类似 以主从机制（多机器）为基础的分布式锁，也是不够的，因为redis在进行主从复制时是异步完成的，比如在clientA获取锁后，主redis复制数据到从redis过程中崩溃了，导致锁没有复制到从redis中，然后从redis选举出一个升级为主redis，造成新的主redis没有clientA设置的锁，这时clientB尝试获取锁，并且能够成功获取锁，导致互斥失效。 针对以上问题，redis官方设计了Redlock，在Node.js环境下对应的资源库为node-redlock，可以用npm安装，至少需要3个独立的服务器或集群才能使用，提供了非常高的容错率，在生产环境中应该优先采用此方案部署。 总结秒杀场景的特点可以总结为瞬时并发访问、读多写少、限时和限量，开发中还要考虑避免超卖现象以及类似黄牛抢票的限购问题，针对以上特点和问题，分析得到开发的原则是：数据写入内存而不是写入硬盘，异步处理而不是同步处理，扣库存操作原子执行以及对单用户购买进行加锁，而Redis正好是符合以上全部特点的工具，因此最终选择Redis来解决问题。 秒杀场景是一个在电商业务中相对复杂的场景，此篇文章只是介绍了其中最核心的逻辑，实际业务可能更加复杂，但只需要在此核心基础上进行扩展和优化即可。秒杀场景的解决方案不仅仅适合秒杀，类似的还有抢红包、抢优惠券以及抢票等等，思路都是一致的。解决方案的思路还可以应用在单独限购、第二件半价以及控制库存等等诸多场景，大家要灵活运用。 项目地址https://github.com/threerocks/redis-seckill 参考资料https://time.geekbang.org/column/article/307421https://redis.io/topics/distlock","categories":[],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://threerocks.github.io/tags/Node-js/"},{"name":"Javascript","slug":"Javascript","permalink":"https://threerocks.github.io/tags/Javascript/"},{"name":"Mysql","slug":"Mysql","permalink":"https://threerocks.github.io/tags/Mysql/"},{"name":"Redis","slug":"Redis","permalink":"https://threerocks.github.io/tags/Redis/"},{"name":"秒杀","slug":"秒杀","permalink":"https://threerocks.github.io/tags/%E7%A7%92%E6%9D%80/"}]}],"categories":[],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://threerocks.github.io/tags/Promise/"},{"name":"Node.js","slug":"Node-js","permalink":"https://threerocks.github.io/tags/Node-js/"},{"name":"Javascript","slug":"Javascript","permalink":"https://threerocks.github.io/tags/Javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://threerocks.github.io/tags/ES6/"},{"name":"异步","slug":"异步","permalink":"https://threerocks.github.io/tags/%E5%BC%82%E6%AD%A5/"},{"name":"Mysql","slug":"Mysql","permalink":"https://threerocks.github.io/tags/Mysql/"},{"name":"Redis","slug":"Redis","permalink":"https://threerocks.github.io/tags/Redis/"},{"name":"秒杀","slug":"秒杀","permalink":"https://threerocks.github.io/tags/%E7%A7%92%E6%9D%80/"}]}