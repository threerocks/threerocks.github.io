{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/bubuzou/source/css/bubuzou.css","path":"css/bubuzou.css","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/font/sourcesanspro.woff","path":"font/sourcesanspro.woff","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/font/sourcesanspro.woff2","path":"font/sourcesanspro.woff2","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/abstract.png","path":"images/abstract.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/alert.png","path":"images/alert.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/cate.png","path":"images/cate.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/icon_dot.jpg","path":"images/icon_dot.jpg","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/icon_doton.jpg","path":"images/icon_doton.jpg","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/logo.png","path":"images/logo.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/readme.png","path":"images/readme.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/right-menu.png","path":"images/right-menu.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/search.png","path":"images/search.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/search_white.png","path":"images/search_white.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/totop.png","path":"images/totop.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/images/totop2.png","path":"images/totop2.png","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/scripts/articleCatalog.js","path":"scripts/articleCatalog.js","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/scripts/jquery-1.8.2.min.js","path":"scripts/jquery-1.8.2.min.js","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/scripts/main.js","path":"scripts/main.js","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/scripts/valine.min.js","path":"scripts/valine.min.js","modified":1,"renderable":1},{"_id":"themes/bubuzou/source/scss/bubuzou.scss","path":"scss/bubuzou.scss","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Promise知识汇总以及面试情况.md","hash":"2c42b6fdacd6a00e71a0e5a285b93e6540b3df41","modified":1624615812000},{"_id":"source/_posts/Redis应用实战 - 秒杀场景（Node.js版本）.md","hash":"8efc4bcfea6fc25dfbcbea69ba7327d5961b0d84","modified":1624615839000},{"_id":"source/about/index.md","hash":"a5a1e9528ea2f184b0b64a39feb9c195e1264c4a","modified":1624610971000},{"_id":"themes/bubuzou/.gitattributes","hash":"4a3348fc9a3d1ec1bc517399089440028e2242fd","modified":1617623050000},{"_id":"themes/bubuzou/.gitignore","hash":"3809d45d6f3670729017961126fee68de00eebb3","modified":1617623050000},{"_id":"themes/bubuzou/LICENSE","hash":"6e31ac9076bfc8f09ae47977419eee4edfb63e5b","modified":1617623050000},{"_id":"themes/bubuzou/README.md","hash":"e0f30a4d71762773a5c6260781dedbe903ba4bf8","modified":1617623050000},{"_id":"themes/bubuzou/_config.yml","hash":"d63953baf3ff023adb862f7fd9619a840ce412bc","modified":1624617028000},{"_id":"themes/bubuzou/gulpfile.js","hash":"857a026b6643a2cd52c65d4ae0dc7fe9618206ee","modified":1617623050000},{"_id":"themes/bubuzou/package.json","hash":"c9576474f51c2c1bfc8f5978f6fc688c1cabdea7","modified":1617623050000},{"_id":"themes/bubuzou/doc/doc-zh.md","hash":"d51414320c7a35ae3b7adf31dbaed4e94537a40b","modified":1617623050000},{"_id":"themes/bubuzou/languages/en.yml","hash":"40292f2a48e4e6361132033a47c516cb33127b6c","modified":1617623050000},{"_id":"themes/bubuzou/languages/zh-cn.yml","hash":"9e4b03e14c094000257ea254fd660dde4c7af63c","modified":1617623050000},{"_id":"themes/bubuzou/layout/about.jade","hash":"b9bafb9eaf2ca6d2592fae50703f197f89594fe9","modified":1617623050000},{"_id":"themes/bubuzou/layout/archive.jade","hash":"78b0f13e44b928d228972fbd965b521851b89c12","modified":1617623050000},{"_id":"themes/bubuzou/layout/categories.jade","hash":"b1eb06978e0839b6eaed14a62885f15031bc36eb","modified":1617623050000},{"_id":"themes/bubuzou/layout/index.jade","hash":"55f2f1b4b5364a0e09cb18e1112664c6415fb881","modified":1617623050000},{"_id":"themes/bubuzou/layout/post.jade","hash":"cc8eb899bf54884a33690ab83c75d175838601d6","modified":1617623050000},{"_id":"themes/bubuzou/layout/mixins/paginator.jade","hash":"21ab15eb9cc5d8756afe5239e7009aab8d22de9f","modified":1617623050000},{"_id":"themes/bubuzou/layout/mixins/post.jade","hash":"e161f00a8e57b1ecfef2763fcbceea129f61ef7b","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/comment.jade","hash":"8cf7b8a5e0794ddf1b0df350d325dec1eccf0d57","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/copyright.jade","hash":"ac01227138856eea7dee30e2c4b792a80fbea1ae","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/head.jade","hash":"9566f163316fe802d79a3e341931e36f2a284a69","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/layout.jade","hash":"3b2f949d9f39cedd0003940a7e990bb1aa2acac3","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/nav.jade","hash":"5715d7c7553b13833bd5042d857efda91cbc357d","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/scripts.jade","hash":"8f37f4d112e365d64bb75ee793be1918b03c2f71","modified":1617623050000},{"_id":"themes/bubuzou/layout/partial/timer.jade","hash":"58cda085f50c6200c82296d4c7401bb80963c029","modified":1617623050000},{"_id":"themes/bubuzou/layout/widget/catalog.jade","hash":"62549364cbf1f978b06400195283ee89eeb0dd4a","modified":1617623050000},{"_id":"themes/bubuzou/layout/widget/category.jade","hash":"8aa2a1c644cec1c4b7e82b5d39a8170a5b9fc344","modified":1617623050000},{"_id":"themes/bubuzou/layout/widget/recent.jade","hash":"46d18b96d3abc8f8115f80cb7a1816bccafbac76","modified":1617623050000},{"_id":"themes/bubuzou/layout/widget/tagcloud.jade","hash":"6238cda8b15e15863dc1f9c8cbf1f69ca7fd5be0","modified":1617623050000},{"_id":"themes/bubuzou/source/css/bubuzou.css","hash":"2ca2550e10658474ddec0a09e794519bbb2272a1","modified":1617623050000},{"_id":"themes/bubuzou/source/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1617623050000},{"_id":"themes/bubuzou/source/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1617623050000},{"_id":"themes/bubuzou/source/images/abstract.png","hash":"f981405269dbd0e8004364ebcb8220c58934ef31","modified":1617623050000},{"_id":"themes/bubuzou/source/images/alert.png","hash":"1faab50a7d611cec2094e495659037d83ffa9fcb","modified":1617623050000},{"_id":"themes/bubuzou/source/images/cate.png","hash":"8da3b9953df6e425e45a757d60ac04bf3314f683","modified":1617623050000},{"_id":"themes/bubuzou/source/images/favicon.ico","hash":"7ce92af122e926ec1bd4f37e20dbfe734a5343c9","modified":1617623050000},{"_id":"themes/bubuzou/source/images/icon_dot.jpg","hash":"c3184b95085e80aaf819dd01b104908580294813","modified":1617623050000},{"_id":"themes/bubuzou/source/images/icon_doton.jpg","hash":"2a0d0bc38b93f863bcb0f6c814e70d7b122aee30","modified":1617623050000},{"_id":"themes/bubuzou/source/images/logo.png","hash":"e372f19ebeffee8227a12ed5900af9988c6aa58e","modified":1617623050000},{"_id":"themes/bubuzou/source/images/readme.png","hash":"af2e7b2dbd8dc00ded644be760f7de284a2ba8c8","modified":1617623050000},{"_id":"themes/bubuzou/source/images/right-menu.png","hash":"34c301a997297d34b09f54675c3762a468c13e2f","modified":1617623050000},{"_id":"themes/bubuzou/source/images/search.png","hash":"2b8b74dc6677d0e6f868ae00415a075cd66140b4","modified":1617623050000},{"_id":"themes/bubuzou/source/images/search_white.png","hash":"2cd2ae869c53fe9649d6d7da81ba9ae135f81b7d","modified":1617623050000},{"_id":"themes/bubuzou/source/images/totop.png","hash":"08bb08352a17bc42391d997638d1b5df9c979753","modified":1617623050000},{"_id":"themes/bubuzou/source/images/totop2.png","hash":"7a45e9e4b70593c7bdc23fe76c10e546afc933ab","modified":1617623050000},{"_id":"themes/bubuzou/source/scripts/articleCatalog.js","hash":"4c2ddb1e62be91c4a92980acd96b668b02312ae8","modified":1617623050000},{"_id":"themes/bubuzou/source/scripts/main.js","hash":"cbb3e4369ef54b9458b0bca0e8a77982121aab49","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/bubuzou.scss","hash":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/archive-post-list.scss","hash":"d2f740a7d48349b7536777c795f82ab740836d0f","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/base.scss","hash":"fe20c16c18ab76b843d0aab2e1a5cc4f5d6d64c7","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/copyright.scss","hash":"1309667e3000037170cfbb5b8c9c65f4ffcf6814","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/footer.scss","hash":"094aca6e52f11b139ac7980ca03fa7b9d8fc7b2f","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/header.scss","hash":"153bde88bf8ffeae4ffd813d8cc694dd83d33d94","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/home-post-list.scss","hash":"6b5c59f3d2295944f934aee2c1156012a3306d5d","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/mq.scss","hash":"b5eb0fb35fb275cbb6452b5d98702d461af3e6d5","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/normalize.scss","hash":"fd0b27bed6f103ea95b08f698ea663ff576dbcf1","modified":1617623050000},{"_id":"themes/bubuzou/source/scss/_partial/post.scss","hash":"ae780828148f79e5069b480e3576f1fea1246866","modified":1617623050000},{"_id":"themes/bubuzou/source/scripts/jquery-1.8.2.min.js","hash":"d09d3a99ed25d0f1fbe6856de9e14ffd33557256","modified":1617623050000},{"_id":"themes/bubuzou/source/scripts/valine.min.js","hash":"ede5d4e0bc808cc8d9852b176237dc9b951a7045","modified":1617623050000},{"_id":"public/atom.xml","hash":"7b64020bbbfa243f34c7e75138605156d32fe880","modified":1624617042042},{"_id":"public/content.json","hash":"ba7e2760d699cb0644c9d667099b1f97dbf65708","modified":1624617042042},{"_id":"public/search.xml","hash":"f3f15e86e470cbea4d6b732d1b0f6268774fceba","modified":1624617042042},{"_id":"public/sitemap.xml","hash":"3100d348fcf3a1bc76693b34b3e89f192b8957c6","modified":1624617042042},{"_id":"public/about/index.html","hash":"59bf8c95e2c94ff3a958e40e85e16abb9009a1c1","modified":1624617042042},{"_id":"public/archives/index.html","hash":"536b7ef07ccfbae4ffde99d3f5da8f6945151245","modified":1624617042042},{"_id":"public/index.html","hash":"835a58d4558ff20f8f78edcd07a56b3828b31826","modified":1624617042042},{"_id":"public/tags/Promise/index.html","hash":"4f1cc0918167a9e05bca50f2ccfd8e3f6fba2cac","modified":1624617042042},{"_id":"public/tags/Node-js/index.html","hash":"536b7ef07ccfbae4ffde99d3f5da8f6945151245","modified":1624617042042},{"_id":"public/tags/Javascript/index.html","hash":"536b7ef07ccfbae4ffde99d3f5da8f6945151245","modified":1624617042042},{"_id":"public/tags/ES6/index.html","hash":"4f1cc0918167a9e05bca50f2ccfd8e3f6fba2cac","modified":1624617042042},{"_id":"public/tags/异步/index.html","hash":"4f1cc0918167a9e05bca50f2ccfd8e3f6fba2cac","modified":1624617042042},{"_id":"public/tags/Mysql/index.html","hash":"efe8ffe6f380f7d93012a72f54c13a3cf8dad6f3","modified":1624617042042},{"_id":"public/tags/Redis/index.html","hash":"efe8ffe6f380f7d93012a72f54c13a3cf8dad6f3","modified":1624617042042},{"_id":"public/tags/秒杀/index.html","hash":"efe8ffe6f380f7d93012a72f54c13a3cf8dad6f3","modified":1624617042042},{"_id":"public/2021/06/25/Promise知识汇总以及面试情况/index.html","hash":"266381f897ed3d1961e63a7ab082dda7c3c004a9","modified":1624617042042},{"_id":"public/2021/06/25/Redis应用实战 - 秒杀场景（Node.js版本）/index.html","hash":"f7d2ab827e69d04ec61bf665108f377845d6263c","modified":1624617042042},{"_id":"public/font/sourcesanspro.woff","hash":"a6722c9b6439b7a020a9be3d3178970757a9265c","modified":1624617042042},{"_id":"public/font/sourcesanspro.woff2","hash":"da65f527a8da65d5eb6721626d28cfdb46ab104a","modified":1624617042042},{"_id":"public/images/abstract.png","hash":"f981405269dbd0e8004364ebcb8220c58934ef31","modified":1624617042042},{"_id":"public/images/alert.png","hash":"1faab50a7d611cec2094e495659037d83ffa9fcb","modified":1624617042042},{"_id":"public/images/cate.png","hash":"8da3b9953df6e425e45a757d60ac04bf3314f683","modified":1624617042042},{"_id":"public/images/favicon.ico","hash":"7ce92af122e926ec1bd4f37e20dbfe734a5343c9","modified":1624617042042},{"_id":"public/images/icon_dot.jpg","hash":"c3184b95085e80aaf819dd01b104908580294813","modified":1624617042042},{"_id":"public/images/icon_doton.jpg","hash":"2a0d0bc38b93f863bcb0f6c814e70d7b122aee30","modified":1624617042042},{"_id":"public/images/logo.png","hash":"e372f19ebeffee8227a12ed5900af9988c6aa58e","modified":1624617042042},{"_id":"public/images/readme.png","hash":"af2e7b2dbd8dc00ded644be760f7de284a2ba8c8","modified":1624617042042},{"_id":"public/images/right-menu.png","hash":"34c301a997297d34b09f54675c3762a468c13e2f","modified":1624617042042},{"_id":"public/images/search.png","hash":"2b8b74dc6677d0e6f868ae00415a075cd66140b4","modified":1624617042042},{"_id":"public/images/search_white.png","hash":"2cd2ae869c53fe9649d6d7da81ba9ae135f81b7d","modified":1624617042042},{"_id":"public/images/totop.png","hash":"08bb08352a17bc42391d997638d1b5df9c979753","modified":1624617042042},{"_id":"public/images/totop2.png","hash":"7a45e9e4b70593c7bdc23fe76c10e546afc933ab","modified":1624617042042},{"_id":"public/scss/bubuzou.scss","hash":"153bbf882c1f6f65bb4510999b51812e20016ca7","modified":1624617042042},{"_id":"public/scripts/articleCatalog.js","hash":"4c2ddb1e62be91c4a92980acd96b668b02312ae8","modified":1624617042042},{"_id":"public/scripts/main.js","hash":"cbb3e4369ef54b9458b0bca0e8a77982121aab49","modified":1624617042042},{"_id":"public/css/bubuzou.css","hash":"2ca2550e10658474ddec0a09e794519bbb2272a1","modified":1624617042042},{"_id":"public/scripts/valine.min.js","hash":"ede5d4e0bc808cc8d9852b176237dc9b951a7045","modified":1624617042042},{"_id":"public/scripts/jquery-1.8.2.min.js","hash":"d09d3a99ed25d0f1fbe6856de9e14ffd33557256","modified":1624617042042}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2021-06-25T08:43:56.000Z","categories":["Diary"],"tags":["PS3","Games"],"_content":"\n\n### asdjasdk\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-06-25 16:43:56\ncategories:\n- Diary\ntags:\n- PS3\n- Games\n---\n\n\n### asdjasdk\n","updated":"2021-06-25T08:49:31.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckqc71gud0000txzb9s18ed4r","content":"<h3 id=\"asdjasdk\"><a href=\"#asdjasdk\" class=\"headerlink\" title=\"asdjasdk\"></a>asdjasdk</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"asdjasdk\"><a href=\"#asdjasdk\" class=\"headerlink\" title=\"asdjasdk\"></a>asdjasdk</h3>"}],"Post":[{"title":"Promise知识汇总以及面试情况","date":"2021-06-25T09:59:29.000Z","_content":"\n## 写在前面\nJavascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 [Promise/A+](https://promisesaplus.com/) 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。   \n\n关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。\n\n<!--more-->\n\n## 实现Promise\n### 规范解读\n[Promise/A+](https://promisesaplus.com/)规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版[Promise/A+](https://promisesaplus.com/)标准。\n>1、`Promise`有三种状态`pending`，`fulfilled`和`rejected`。（为了一致性，此文章称`fulfilled`状态为`resolved`状态）\n> \n>> - 状态转换只能是`pending`到`resolved`或者`pending`到`rejected`；\n>> - 状态一旦转换完成，不能再次转换。\n>\n>2、Promise拥有一个then方法，用以处理`resolved`或`rejected`状态下的值。\n>\n>> - then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。\n>> - then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise）\n     - onResolved/onRejected有返回值则把返回值定义为x，并执行\\[\\[Resolve\\]\\](promise2, x);\n     - onResolved/onRejected运行出错，则把promise2设置为`rejected`状态；\n     - onResolved/onRejected不是函数，则需要把promise1的状态传递下去。\n>\n>3、不同的Promise实现可以的交互。\n>\n>>- 规范中称这一步操作为Promise解决过程，函数标示为\\[\\[Resolve\\]\\](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。\n>>- \\[\\[Resolve\\]\\](promise, x)函数具体运行规则：\n    - 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise;\n    - 如果 x 为 Promise ，则使 promise 接受 x 的状态;\n    - 如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入`rejected`状态，如果then不是函数，同样让promise进入`rejected`状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用\\[\\[Resolve\\]\\](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入`rejected`状态；\n    - 如果 x 不是对象或者函数，直接就用x的值来执行promise。\n\n### 代码实现\n规范解读第1条，代码实现：\n\n```js\nclass Promise {\n  // 定义Promise状态变量，初始值为pending\n  status = 'pending';\n  // 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值\n  data = '';\n\n  // Promise构造函数，传入参数为一个可执行的函数\n  constructor(executor) {\n    // resolve函数负责把状态转换为resolved\n    function resolve(value) {\n      this.status = 'resolved';\n      this.data = value;\n    }\n    // reject函数负责把状态转换为rejected\n    function reject(reason) {\n      this.status = 'rejected';\n      this.data = reason;\n    }\n\n    // 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject\n    try {\n      executor(resolve, reject);\n    } catch(e) {\n      reject(e)\n    }\n  }\n}\n```\n\n规范解读第2条，代码实现：\n\n```js\n  /**\n    * 拥有一个then方法\n    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected\n    * 返回一个新的Promise\n  */\n  then(onResolved, onRejected) {\n    // 设置then的默认参数，默认参数实现Promise的值的穿透\n    onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return e };\n    onRejected = typeof onRejected === 'function' ? onRejected : function(e) { throw e };\n    \n    let promise2;\n    \n    promise2 =  new Promise((resolve, reject) => {\n      // 如果状态为resolved，则执行onResolved\n      if (this.status === 'resolved') {\n        try {\n          // onResolved/onRejected有返回值则把返回值定义为x\n          const x = onResolved(this.data);\n          // 执行[[Resolve]](promise2, x)\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      }\n      // 如果状态为rejected，则执行onRejected\n      if (this.status === 'rejected') {\n        try {\n          const x = onRejected(this.data);\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n    \n    return promise2;\n  }\n```\n现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下\n1. resolvePromise未定义；\n2. then方法执行的时候，promise可能仍然处于`pending`状态，因为`executor`中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机；\n3. onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的)\n\n解决办法：\n1. 根据规范解读第3条，定义并实现resolvePromise函数；\n2. then方法执行时如果promise仍然处于`pending`状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。\n3. Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐[这篇文章](https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA)。\n\n好了，有了解决办法，我们就把代码进一步完善：\n\n```js\nclass Promise {\n  // 定义Promise状态变量，初始值为pending\n  status = 'pending';\n  // 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值\n  data = '';\n  // Promise resolve时的回调函数集\n  onResolvedCallback = [];\n  // Promise reject时的回调函数集\n  onRejectedCallback = [];\n\n  // Promise构造函数，传入参数为一个可执行的函数\n  constructor(executor) {\n    // resolve函数负责把状态转换为resolved\n    function resolve(value) {\n      this.status = 'resolved';\n      this.data = value;\n      for (const func of this.onResolvedCallback) {\n        func(this.data);\n      }\n    }\n    // reject函数负责把状态转换为rejected\n    function reject(reason) {\n      this.status = 'rejected';\n      this.data = reason;\n      for (const func of this.onRejectedCallback) {\n        func(this.data);\n      }\n    }\n\n    // 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject\n    try {\n      executor(resolve, reject);\n    } catch(e) {\n      reject(e)\n    }\n  }\n  /**\n    * 拥有一个then方法\n    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected\n    * 返回一个新的Promise\n  */\n  then(onResolved, onRejected) {\n\n    // 设置then的默认参数，默认参数实现Promise的值的穿透\n    onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return e };\n    onRejected = typeof onRejected === 'function' ? onRejected : function(e) { throw e };\n\n    let promise2;\n\n    promise2 =  new Promise((resolve, reject) => {\n      // 如果状态为resolved，则执行onResolved\n      if (this.status === 'resolved') {\n        setTimeout(() => {\n          try {\n            // onResolved/onRejected有返回值则把返回值定义为x\n            const x = onResolved(this.data);\n            // 执行[[Resolve]](promise2, x)\n            this.resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      }\n      // 如果状态为rejected，则执行onRejected\n      if (this.status === 'rejected') {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.data);\n            this.resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      }\n      // 如果状态为pending，则把处理函数进行存储\n      if (this.status = 'pending') {\n        this.onResolvedCallback.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onResolved(this.data);\n              this.resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0);\n        });\n\n        this.onRejectedCallback.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onRejected(this.data);\n              this.resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0);\n        });\n      }\n\n    });\n\n    return promise2;\n  }\n\n  // [[Resolve]](promise2, x)函数\n  resolvePromise(promise2, x, resolve, reject) {\n    \n  }\n  \n}\n```\n\n至此，规范中关于then的部分就全部实现完毕了。\n\n规范解读第3条，代码实现：\n\n```js\n// [[Resolve]](promise2, x)函数\n  resolvePromise(promise2, x, resolve, reject) {\n    let called = false;\n\n    if (promise2 === x) {\n      return reject(new TypeError('Chaining cycle detected for promise!'))\n    }\n    \n    // 如果x仍然为Promise的情况\n    if (x instanceof Promise) {\n      // 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise\n      if (x.status === 'pending') {\n        x.then(function(value) {\n          resolvePromise(promise2, value, resolve, reject)\n        }, reject)\n      } else { \n        // 如果x状态已经确定了，直接取它的状态\n        x.then(resolve, reject)\n      }\n      return\n    }\n  \n    if (x !== null && (Object.prototype.toString(x) === '[object Object]' || Object.prototype.toString(x) === '[object Function]')) {\n      try {\n        // 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制\n        const then = x.then \n        // then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值\n        if (typeof then === 'function') { \n          then.call(x, (y) => { \n            if (called) return;\n            called = true;\n            this.resolvePromise(promise2, y, resolve, reject);\n          }, (r) => {\n            if (called) return;\n            called = true;\n            reject(r);\n          })\n        } else { // 如果then不是函数，那就说明x不是thenable，直接resolve x\n          if (called) return ;\n          called = true;\n          resolve(x);\n        }\n      } catch (e) {\n        if (called) return;\n        called = true;\n        reject(e);\n      }\n    } else {\n      resolve(x);\n    }\n  }\n```\n\n这一步骤非常简单，只要按照规范转换成代码即可。\n\n最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。\n\n### Promise其他方法实现\n#### 1、catch方法\ncatch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。\n\n```js\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n```\n\n#### 2、done方法\ncatch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。\n\n```js\n  done() {\n    this.catch(reason => {\n      console.log('done', reason);\n      throw reason;\n    });\n  }\n```\n\n#### 3、finally方法\nfinally方法用于无论是resolve还是reject，finally的参数函数都会被执行。\n\n```js\n  finally(fn) {\n    return this.then(value => {\n      fn();\n      return value;\n    }, reason => {\n      fn();\n      throw reason;\n    });\n  };\n```\n\n#### 4、Promise.all方法\nPromise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为`resolved`时，promise2状态为`resolved`并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。\n\n```js\n  static all(promiseList) {\n    return new Promise((resolve, reject) => {\n      const result = [];\n      let i = 0;\n      for (const p of promiseList) {\n        p.then(value => {\n          result[i] = value;\n          if (result.length === promiseList.length) {\n            resolve(result);\n          }\n        }, reject);\n        i++;\n      }\n    });\n  }\n```\n#### 5、Promise.race方法\nPromise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。\n\n```js\n  static race(promiseList) {\n    return new Promise((resolve, reject) => {\n      for (const p of promiseList) {\n        p.then((value) => {\n          resolve(value);   \n        }, reject);\n      }\n    });\n  }\n```\n\n#### 6、Promise.resolve方法/Promise.reject\nPromise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。\n\n```js\n  static resolve(value) {\n    let promise;\n\n    promise = new Promise((resolve, reject) => {\n      this.resolvePromise(promise, value, resolve, reject);\n    });\n  \n    return promise;\n  }\n  \n  static reject(reason) {\n    return new Promise((resolve, reject) => {\n      reject(reason);\n    });\n  }\n```\n\n常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。\n\n## Promise面试相关\n面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。\nPromise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。\n### 简单介绍下Promise。\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\n（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的）\n\n- 提问概率：99%\n- 评分标准：人性化判断即可，此问题一般作为引入问题。\n- 加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。\n\n### 实现一个简单的，支持异步链式调用的Promise类。\n这个答案不是固定的，可以参考[最简实现 Promise，支持异步链式调用](https://juejin.cn/post/6844904094079926286)\n\n- 提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识）\n- 加分项：onResolved/onRejected函数异步调用，错误捕获合理等\n\n### Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)\nJS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）\nEvent Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）\n浏览器运行机制可参考[这篇文章](https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA)\n\n- 提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解）\n- 加分项：扩展讲述浏览器运行机制。\n\n### 阐述Promise的一些方法。\nPromise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等\n\n- 提问概率：25%\n- 加分项：越多越好\n\n### Promise存在哪些缺点。\n1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）\n4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。\n\n- 提问概率：25%（此问题作为提高题目，出现概率不高）\n- 加分项：越多越合理越好\n\n### 使用Promise进行顺序（sequence）处理。\n1、使用async函数配合await或者使用generator函数配合yield。\n2、使用promise.then通过for循环或者Array.prototype.reduce实现。\n\n```js\nfunction sequenceTasks(tasks) {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    var pushValue = recordValue.bind(null, []);\n    return tasks.reduce(function (promise, task) {\n        return promise.then(() => task).then(pushValue);\n    }, Promise.resolve());\n}\n```\n\n- 提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用）\n- 评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。\n\n### 如何停止一个Promise链？\n在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。\n\n```js\n    Promise.cancel = Promise.stop = function() {\n      return new Promise(function(){})\n    }\n```\n\n- 提问概率：50%（此问题主要考察面试者罗辑思维）\n\n### Promise链上返回的最后一个Promise出错了怎么办？\ncatch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。\n\n```js\n  done() {\n    this.catch(reason => {\n      console.log('done', reason);\n      throw reason;\n    });\n  }\n```\n\n- 提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度）\n- 加分项：给出具体的done()方法代码\n\n### Promise存在哪些使用技巧或者最佳实践？\n1、链式Promise要返回一个Promise，而不只是构造一个Promise。\n2、合理的使用Promise.all和Promise.race等方法。\n3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。\n\n- 提问概率：10%（出题概率极低的一个题目）\n- 加分项：越多越好\n\n\n参考链接：\n[http://liubin.org/promises-book](http://liubin.org/promises-book/)\n[https://github.com/xieranmaya/blog/issues/3](https://github.com/xieranmaya/blog/issues/3)\n[https://segmentfault.com/a/1190000016550260](https://segmentfault.com/a/1190000016550260)\n\n\n","source":"_posts/Promise知识汇总以及面试情况.md","raw":"---\ntitle: Promise知识汇总以及面试情况\ndate: 2021-06-25 17:59:29\ntags:\n- Promise\n- Node.js\n- Javascript\n- ES6\n- 异步\n---\n\n## 写在前面\nJavascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 [Promise/A+](https://promisesaplus.com/) 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。   \n\n关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。\n\n<!--more-->\n\n## 实现Promise\n### 规范解读\n[Promise/A+](https://promisesaplus.com/)规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版[Promise/A+](https://promisesaplus.com/)标准。\n>1、`Promise`有三种状态`pending`，`fulfilled`和`rejected`。（为了一致性，此文章称`fulfilled`状态为`resolved`状态）\n> \n>> - 状态转换只能是`pending`到`resolved`或者`pending`到`rejected`；\n>> - 状态一旦转换完成，不能再次转换。\n>\n>2、Promise拥有一个then方法，用以处理`resolved`或`rejected`状态下的值。\n>\n>> - then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。\n>> - then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise）\n     - onResolved/onRejected有返回值则把返回值定义为x，并执行\\[\\[Resolve\\]\\](promise2, x);\n     - onResolved/onRejected运行出错，则把promise2设置为`rejected`状态；\n     - onResolved/onRejected不是函数，则需要把promise1的状态传递下去。\n>\n>3、不同的Promise实现可以的交互。\n>\n>>- 规范中称这一步操作为Promise解决过程，函数标示为\\[\\[Resolve\\]\\](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。\n>>- \\[\\[Resolve\\]\\](promise, x)函数具体运行规则：\n    - 如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise;\n    - 如果 x 为 Promise ，则使 promise 接受 x 的状态;\n    - 如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入`rejected`状态，如果then不是函数，同样让promise进入`rejected`状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用\\[\\[Resolve\\]\\](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入`rejected`状态；\n    - 如果 x 不是对象或者函数，直接就用x的值来执行promise。\n\n### 代码实现\n规范解读第1条，代码实现：\n\n```js\nclass Promise {\n  // 定义Promise状态变量，初始值为pending\n  status = 'pending';\n  // 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值\n  data = '';\n\n  // Promise构造函数，传入参数为一个可执行的函数\n  constructor(executor) {\n    // resolve函数负责把状态转换为resolved\n    function resolve(value) {\n      this.status = 'resolved';\n      this.data = value;\n    }\n    // reject函数负责把状态转换为rejected\n    function reject(reason) {\n      this.status = 'rejected';\n      this.data = reason;\n    }\n\n    // 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject\n    try {\n      executor(resolve, reject);\n    } catch(e) {\n      reject(e)\n    }\n  }\n}\n```\n\n规范解读第2条，代码实现：\n\n```js\n  /**\n    * 拥有一个then方法\n    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected\n    * 返回一个新的Promise\n  */\n  then(onResolved, onRejected) {\n    // 设置then的默认参数，默认参数实现Promise的值的穿透\n    onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return e };\n    onRejected = typeof onRejected === 'function' ? onRejected : function(e) { throw e };\n    \n    let promise2;\n    \n    promise2 =  new Promise((resolve, reject) => {\n      // 如果状态为resolved，则执行onResolved\n      if (this.status === 'resolved') {\n        try {\n          // onResolved/onRejected有返回值则把返回值定义为x\n          const x = onResolved(this.data);\n          // 执行[[Resolve]](promise2, x)\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      }\n      // 如果状态为rejected，则执行onRejected\n      if (this.status === 'rejected') {\n        try {\n          const x = onRejected(this.data);\n          resolvePromise(promise2, x, resolve, reject);\n        } catch (e) {\n          reject(e);\n        }\n      }\n    });\n    \n    return promise2;\n  }\n```\n现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下\n1. resolvePromise未定义；\n2. then方法执行的时候，promise可能仍然处于`pending`状态，因为`executor`中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机；\n3. onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的)\n\n解决办法：\n1. 根据规范解读第3条，定义并实现resolvePromise函数；\n2. then方法执行时如果promise仍然处于`pending`状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。\n3. Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐[这篇文章](https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA)。\n\n好了，有了解决办法，我们就把代码进一步完善：\n\n```js\nclass Promise {\n  // 定义Promise状态变量，初始值为pending\n  status = 'pending';\n  // 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值\n  data = '';\n  // Promise resolve时的回调函数集\n  onResolvedCallback = [];\n  // Promise reject时的回调函数集\n  onRejectedCallback = [];\n\n  // Promise构造函数，传入参数为一个可执行的函数\n  constructor(executor) {\n    // resolve函数负责把状态转换为resolved\n    function resolve(value) {\n      this.status = 'resolved';\n      this.data = value;\n      for (const func of this.onResolvedCallback) {\n        func(this.data);\n      }\n    }\n    // reject函数负责把状态转换为rejected\n    function reject(reason) {\n      this.status = 'rejected';\n      this.data = reason;\n      for (const func of this.onRejectedCallback) {\n        func(this.data);\n      }\n    }\n\n    // 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject\n    try {\n      executor(resolve, reject);\n    } catch(e) {\n      reject(e)\n    }\n  }\n  /**\n    * 拥有一个then方法\n    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected\n    * 返回一个新的Promise\n  */\n  then(onResolved, onRejected) {\n\n    // 设置then的默认参数，默认参数实现Promise的值的穿透\n    onResolved = typeof onResolved === 'function' ? onResolved : function(v) { return e };\n    onRejected = typeof onRejected === 'function' ? onRejected : function(e) { throw e };\n\n    let promise2;\n\n    promise2 =  new Promise((resolve, reject) => {\n      // 如果状态为resolved，则执行onResolved\n      if (this.status === 'resolved') {\n        setTimeout(() => {\n          try {\n            // onResolved/onRejected有返回值则把返回值定义为x\n            const x = onResolved(this.data);\n            // 执行[[Resolve]](promise2, x)\n            this.resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      }\n      // 如果状态为rejected，则执行onRejected\n      if (this.status === 'rejected') {\n        setTimeout(() => {\n          try {\n            const x = onRejected(this.data);\n            this.resolvePromise(promise2, x, resolve, reject);\n          } catch (e) {\n            reject(e);\n          }\n        }, 0);\n      }\n      // 如果状态为pending，则把处理函数进行存储\n      if (this.status = 'pending') {\n        this.onResolvedCallback.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onResolved(this.data);\n              this.resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0);\n        });\n\n        this.onRejectedCallback.push(() => {\n          setTimeout(() => {\n            try {\n              const x = onRejected(this.data);\n              this.resolvePromise(promise2, x, resolve, reject);\n            } catch (e) {\n              reject(e);\n            }\n          }, 0);\n        });\n      }\n\n    });\n\n    return promise2;\n  }\n\n  // [[Resolve]](promise2, x)函数\n  resolvePromise(promise2, x, resolve, reject) {\n    \n  }\n  \n}\n```\n\n至此，规范中关于then的部分就全部实现完毕了。\n\n规范解读第3条，代码实现：\n\n```js\n// [[Resolve]](promise2, x)函数\n  resolvePromise(promise2, x, resolve, reject) {\n    let called = false;\n\n    if (promise2 === x) {\n      return reject(new TypeError('Chaining cycle detected for promise!'))\n    }\n    \n    // 如果x仍然为Promise的情况\n    if (x instanceof Promise) {\n      // 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise\n      if (x.status === 'pending') {\n        x.then(function(value) {\n          resolvePromise(promise2, value, resolve, reject)\n        }, reject)\n      } else { \n        // 如果x状态已经确定了，直接取它的状态\n        x.then(resolve, reject)\n      }\n      return\n    }\n  \n    if (x !== null && (Object.prototype.toString(x) === '[object Object]' || Object.prototype.toString(x) === '[object Function]')) {\n      try {\n        // 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制\n        const then = x.then \n        // then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值\n        if (typeof then === 'function') { \n          then.call(x, (y) => { \n            if (called) return;\n            called = true;\n            this.resolvePromise(promise2, y, resolve, reject);\n          }, (r) => {\n            if (called) return;\n            called = true;\n            reject(r);\n          })\n        } else { // 如果then不是函数，那就说明x不是thenable，直接resolve x\n          if (called) return ;\n          called = true;\n          resolve(x);\n        }\n      } catch (e) {\n        if (called) return;\n        called = true;\n        reject(e);\n      }\n    } else {\n      resolve(x);\n    }\n  }\n```\n\n这一步骤非常简单，只要按照规范转换成代码即可。\n\n最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。\n\n### Promise其他方法实现\n#### 1、catch方法\ncatch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。\n\n```js\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n```\n\n#### 2、done方法\ncatch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。\n\n```js\n  done() {\n    this.catch(reason => {\n      console.log('done', reason);\n      throw reason;\n    });\n  }\n```\n\n#### 3、finally方法\nfinally方法用于无论是resolve还是reject，finally的参数函数都会被执行。\n\n```js\n  finally(fn) {\n    return this.then(value => {\n      fn();\n      return value;\n    }, reason => {\n      fn();\n      throw reason;\n    });\n  };\n```\n\n#### 4、Promise.all方法\nPromise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为`resolved`时，promise2状态为`resolved`并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。\n\n```js\n  static all(promiseList) {\n    return new Promise((resolve, reject) => {\n      const result = [];\n      let i = 0;\n      for (const p of promiseList) {\n        p.then(value => {\n          result[i] = value;\n          if (result.length === promiseList.length) {\n            resolve(result);\n          }\n        }, reject);\n        i++;\n      }\n    });\n  }\n```\n#### 5、Promise.race方法\nPromise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。\n\n```js\n  static race(promiseList) {\n    return new Promise((resolve, reject) => {\n      for (const p of promiseList) {\n        p.then((value) => {\n          resolve(value);   \n        }, reject);\n      }\n    });\n  }\n```\n\n#### 6、Promise.resolve方法/Promise.reject\nPromise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。\n\n```js\n  static resolve(value) {\n    let promise;\n\n    promise = new Promise((resolve, reject) => {\n      this.resolvePromise(promise, value, resolve, reject);\n    });\n  \n    return promise;\n  }\n  \n  static reject(reason) {\n    return new Promise((resolve, reject) => {\n      reject(reason);\n    });\n  }\n```\n\n常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。\n\n## Promise面试相关\n面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。\nPromise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。\n### 简单介绍下Promise。\nPromise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。\n（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的）\n\n- 提问概率：99%\n- 评分标准：人性化判断即可，此问题一般作为引入问题。\n- 加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。\n\n### 实现一个简单的，支持异步链式调用的Promise类。\n这个答案不是固定的，可以参考[最简实现 Promise，支持异步链式调用](https://juejin.cn/post/6844904094079926286)\n\n- 提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识）\n- 加分项：onResolved/onRejected函数异步调用，错误捕获合理等\n\n### Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)\nJS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）\nEvent Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）\n浏览器运行机制可参考[这篇文章](https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA)\n\n- 提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解）\n- 加分项：扩展讲述浏览器运行机制。\n\n### 阐述Promise的一些方法。\nPromise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等\n\n- 提问概率：25%\n- 加分项：越多越好\n\n### Promise存在哪些缺点。\n1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。\n2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。\n3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）\n4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。\n\n- 提问概率：25%（此问题作为提高题目，出现概率不高）\n- 加分项：越多越合理越好\n\n### 使用Promise进行顺序（sequence）处理。\n1、使用async函数配合await或者使用generator函数配合yield。\n2、使用promise.then通过for循环或者Array.prototype.reduce实现。\n\n```js\nfunction sequenceTasks(tasks) {\n    function recordValue(results, value) {\n        results.push(value);\n        return results;\n    }\n    var pushValue = recordValue.bind(null, []);\n    return tasks.reduce(function (promise, task) {\n        return promise.then(() => task).then(pushValue);\n    }, Promise.resolve());\n}\n```\n\n- 提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用）\n- 评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。\n\n### 如何停止一个Promise链？\n在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。\n\n```js\n    Promise.cancel = Promise.stop = function() {\n      return new Promise(function(){})\n    }\n```\n\n- 提问概率：50%（此问题主要考察面试者罗辑思维）\n\n### Promise链上返回的最后一个Promise出错了怎么办？\ncatch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。\n\n```js\n  done() {\n    this.catch(reason => {\n      console.log('done', reason);\n      throw reason;\n    });\n  }\n```\n\n- 提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度）\n- 加分项：给出具体的done()方法代码\n\n### Promise存在哪些使用技巧或者最佳实践？\n1、链式Promise要返回一个Promise，而不只是构造一个Promise。\n2、合理的使用Promise.all和Promise.race等方法。\n3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。\n\n- 提问概率：10%（出题概率极低的一个题目）\n- 加分项：越多越好\n\n\n参考链接：\n[http://liubin.org/promises-book](http://liubin.org/promises-book/)\n[https://github.com/xieranmaya/blog/issues/3](https://github.com/xieranmaya/blog/issues/3)\n[https://segmentfault.com/a/1190000016550260](https://segmentfault.com/a/1190000016550260)\n\n\n","slug":"Promise知识汇总以及面试情况","published":1,"updated":"2021-06-25T10:10:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqc71guk0001txzbh7pffevl","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Javascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 <a href=\"https://promisesaplus.com/\">Promise/A+</a> 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。   </p>\n<p>关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"实现Promise\"><a href=\"#实现Promise\" class=\"headerlink\" title=\"实现Promise\"></a>实现Promise</h2><h3 id=\"规范解读\"><a href=\"#规范解读\" class=\"headerlink\" title=\"规范解读\"></a>规范解读</h3><p><a href=\"https://promisesaplus.com/\">Promise/A+</a>规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版<a href=\"https://promisesaplus.com/\">Promise/A+</a>标准。</p>\n<blockquote>\n<p>1、<code>Promise</code>有三种状态<code>pending</code>，<code>fulfilled</code>和<code>rejected</code>。（为了一致性，此文章称<code>fulfilled</code>状态为<code>resolved</code>状态）</p>\n<blockquote>\n<ul>\n<li>状态转换只能是<code>pending</code>到<code>resolved</code>或者<code>pending</code>到<code>rejected</code>；</li>\n<li>状态一旦转换完成，不能再次转换。</li>\n</ul>\n</blockquote>\n<p>2、Promise拥有一个then方法，用以处理<code>resolved</code>或<code>rejected</code>状态下的值。</p>\n<blockquote>\n<ul>\n<li>then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。</li>\n<li>then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise）<ul>\n<li>onResolved/onRejected有返回值则把返回值定义为x，并执行[[Resolve]](promise2, x);</li>\n<li>onResolved/onRejected运行出错，则把promise2设置为<code>rejected</code>状态；</li>\n<li>onResolved/onRejected不是函数，则需要把promise1的状态传递下去。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>3、不同的Promise实现可以的交互。</p>\n<blockquote>\n<ul>\n<li>规范中称这一步操作为Promise解决过程，函数标示为[[Resolve]](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。</li>\n<li>[[Resolve]](promise, x)函数具体运行规则：<ul>\n<li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise;</li>\n<li>如果 x 为 Promise ，则使 promise 接受 x 的状态;</li>\n<li>如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入<code>rejected</code>状态，如果then不是函数，同样让promise进入<code>rejected</code>状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用[[Resolve]](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入<code>rejected</code>状态；</li>\n<li>如果 x 不是对象或者函数，直接就用x的值来执行promise。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>规范解读第1条，代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义Promise状态变量，初始值为pending</span></span><br><span class=\"line\">  status = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class=\"line\">  data = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">executor</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve函数负责把状态转换为resolved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// reject函数负责把状态转换为rejected</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = reason;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      executor(resolve, reject);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>规范解读第2条，代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 拥有一个then方法</span></span><br><span class=\"line\"><span class=\"comment\">  * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回一个新的Promise</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">onResolved, onRejected</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class=\"line\">  onResolved = <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">&#x27;function&#x27;</span> ? onResolved : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123; <span class=\"keyword\">return</span> e &#125;;</span><br><span class=\"line\">  onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span> ? onRejected : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">throw</span> e &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2;</span><br><span class=\"line\">  </span><br><span class=\"line\">  promise2 =  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果状态为resolved，则执行onResolved</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onResolved(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">        <span class=\"comment\">// 执行[[Resolve]](promise2, x)</span></span><br><span class=\"line\">        resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果状态为rejected，则执行onRejected</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onRejected(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">        resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下</p>\n<ol>\n<li>resolvePromise未定义；</li>\n<li>then方法执行的时候，promise可能仍然处于<code>pending</code>状态，因为<code>executor</code>中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机；</li>\n<li>onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的)</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>根据规范解读第3条，定义并实现resolvePromise函数；</li>\n<li>then方法执行时如果promise仍然处于<code>pending</code>状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。</li>\n<li>Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐<a href=\"https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA\">这篇文章</a>。</li>\n</ol>\n<p>好了，有了解决办法，我们就把代码进一步完善：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义Promise状态变量，初始值为pending</span></span><br><span class=\"line\">  status = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class=\"line\">  data = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">  onResolvedCallback = [];</span><br><span class=\"line\">  <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">  onRejectedCallback = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">executor</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve函数负责把状态转换为resolved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = value;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> func <span class=\"keyword\">of</span> <span class=\"built_in\">this</span>.onResolvedCallback) &#123;</span><br><span class=\"line\">        func(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// reject函数负责把状态转换为rejected</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = reason;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> func <span class=\"keyword\">of</span> <span class=\"built_in\">this</span>.onRejectedCallback) &#123;</span><br><span class=\"line\">        func(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      executor(resolve, reject);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 拥有一个then方法</span></span><br><span class=\"line\"><span class=\"comment\">    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class=\"line\"><span class=\"comment\">    * 返回一个新的Promise</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">onResolved, onRejected</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class=\"line\">    onResolved = <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">&#x27;function&#x27;</span> ? onResolved : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123; <span class=\"keyword\">return</span> e &#125;;</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span> ? onRejected : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">throw</span> e &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> promise2;</span><br><span class=\"line\"></span><br><span class=\"line\">    promise2 =  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果状态为resolved，则执行onResolved</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> x = onResolved(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">            <span class=\"comment\">// 执行[[Resolve]](promise2, x)</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果状态为rejected，则执行onRejected</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> x = onRejected(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果状态为pending，则把处理函数进行存储</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.onResolvedCallback.push(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> x = onResolved(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">              <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">              reject(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.onRejectedCallback.push(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> x = onRejected(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">              <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">              reject(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// [[Resolve]](promise2, x)函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，规范中关于then的部分就全部实现完毕了。</p>\n<p>规范解读第3条，代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [[Resolve]](promise2, x)函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (promise2 === x) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;Chaining cycle detected for promise!&#x27;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果x仍然为Promise的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x.status === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        x.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          resolvePromise(promise2, value, resolve, reject)</span><br><span class=\"line\">        &#125;, reject)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 如果x状态已经确定了，直接取它的状态</span></span><br><span class=\"line\">        x.then(resolve, reject)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (<span class=\"built_in\">Object</span>.prototype.toString(x) === <span class=\"string\">&#x27;[object Object]&#x27;</span> || <span class=\"built_in\">Object</span>.prototype.toString(x) === <span class=\"string\">&#x27;[object Function]&#x27;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> then = x.then </span><br><span class=\"line\">        <span class=\"comment\">// then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">&#x27;function&#x27;</span>) &#123; </span><br><span class=\"line\">          then.call(x, <span class=\"function\">(<span class=\"params\">y</span>) =&gt;</span> &#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">          &#125;, <span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            reject(r);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果then不是函数，那就说明x不是thenable，直接resolve x</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">          called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          resolve(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      resolve(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步骤非常简单，只要按照规范转换成代码即可。</p>\n<p>最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。</p>\n<h3 id=\"Promise其他方法实现\"><a href=\"#Promise其他方法实现\" class=\"headerlink\" title=\"Promise其他方法实现\"></a>Promise其他方法实现</h3><h4 id=\"1、catch方法\"><a href=\"#1、catch方法\" class=\"headerlink\" title=\"1、catch方法\"></a>1、catch方法</h4><p>catch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">catch</span>(onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, onRejected);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、done方法\"><a href=\"#2、done方法\" class=\"headerlink\" title=\"2、done方法\"></a>2、done方法</h4><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">done</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;done&#x27;</span>, reason);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、finally方法\"><a href=\"#3、finally方法\" class=\"headerlink\" title=\"3、finally方法\"></a>3、finally方法</h4><p>finally方法用于无论是resolve还是reject，finally的参数函数都会被执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">finally</span>(<span class=\"params\">fn</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、Promise-all方法\"><a href=\"#4、Promise-all方法\" class=\"headerlink\" title=\"4、Promise.all方法\"></a>4、Promise.all方法</h4><p>Promise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为<code>resolved</code>时，promise2状态为<code>resolved</code>并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">all</span>(<span class=\"params\">promiseList</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> p <span class=\"keyword\">of</span> promiseList) &#123;</span><br><span class=\"line\">      p.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">        result[i] = value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.length === promiseList.length) &#123;</span><br><span class=\"line\">          resolve(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, reject);</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、Promise-race方法\"><a href=\"#5、Promise-race方法\" class=\"headerlink\" title=\"5、Promise.race方法\"></a>5、Promise.race方法</h4><p>Promise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">race</span>(<span class=\"params\">promiseList</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> p <span class=\"keyword\">of</span> promiseList) &#123;</span><br><span class=\"line\">      p.then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(value);   </span><br><span class=\"line\">      &#125;, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、Promise-resolve方法-Promise-reject\"><a href=\"#6、Promise-resolve方法-Promise-reject\" class=\"headerlink\" title=\"6、Promise.resolve方法/Promise.reject\"></a>6、Promise.resolve方法/Promise.reject</h4><p>Promise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">resolve</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise;</span><br><span class=\"line\"></span><br><span class=\"line\">  promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.resolvePromise(promise, value, resolve, reject);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">reject</span>(<span class=\"params\">reason</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    reject(reason);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。</p>\n<h2 id=\"Promise面试相关\"><a href=\"#Promise面试相关\" class=\"headerlink\" title=\"Promise面试相关\"></a>Promise面试相关</h2><p>面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。<br>Promise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。</p>\n<h3 id=\"简单介绍下Promise。\"><a href=\"#简单介绍下Promise。\" class=\"headerlink\" title=\"简单介绍下Promise。\"></a>简单介绍下Promise。</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的）</p>\n<ul>\n<li>提问概率：99%</li>\n<li>评分标准：人性化判断即可，此问题一般作为引入问题。</li>\n<li>加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。</li>\n</ul>\n<h3 id=\"实现一个简单的，支持异步链式调用的Promise类。\"><a href=\"#实现一个简单的，支持异步链式调用的Promise类。\" class=\"headerlink\" title=\"实现一个简单的，支持异步链式调用的Promise类。\"></a>实现一个简单的，支持异步链式调用的Promise类。</h3><p>这个答案不是固定的，可以参考<a href=\"https://juejin.cn/post/6844904094079926286\">最简实现 Promise，支持异步链式调用</a></p>\n<ul>\n<li>提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识）</li>\n<li>加分项：onResolved/onRejected函数异步调用，错误捕获合理等</li>\n</ul>\n<h3 id=\"Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序\"><a href=\"#Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序\" class=\"headerlink\" title=\"Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)\"></a>Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)</h3><p>JS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）<br>Event Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）<br>浏览器运行机制可参考<a href=\"https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA\">这篇文章</a></p>\n<ul>\n<li>提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解）</li>\n<li>加分项：扩展讲述浏览器运行机制。</li>\n</ul>\n<h3 id=\"阐述Promise的一些方法。\"><a href=\"#阐述Promise的一些方法。\" class=\"headerlink\" title=\"阐述Promise的一些方法。\"></a>阐述Promise的一些方法。</h3><p>Promise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等</p>\n<ul>\n<li>提问概率：25%</li>\n<li>加分项：越多越好</li>\n</ul>\n<h3 id=\"Promise存在哪些缺点。\"><a href=\"#Promise存在哪些缺点。\" class=\"headerlink\" title=\"Promise存在哪些缺点。\"></a>Promise存在哪些缺点。</h3><p>1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）<br>4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p>\n<ul>\n<li>提问概率：25%（此问题作为提高题目，出现概率不高）</li>\n<li>加分项：越多越合理越好</li>\n</ul>\n<h3 id=\"使用Promise进行顺序（sequence）处理。\"><a href=\"#使用Promise进行顺序（sequence）处理。\" class=\"headerlink\" title=\"使用Promise进行顺序（sequence）处理。\"></a>使用Promise进行顺序（sequence）处理。</h3><p>1、使用async函数配合await或者使用generator函数配合yield。<br>2、使用promise.then通过for循环或者Array.prototype.reduce实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequenceTasks</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recordValue</span>(<span class=\"params\">results, value</span>) </span>&#123;</span><br><span class=\"line\">        results.push(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pushValue = recordValue.bind(<span class=\"literal\">null</span>, []);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise, task</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise.then(<span class=\"function\">() =&gt;</span> task).then(pushValue);</span><br><span class=\"line\">    &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用）</li>\n<li>评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。</li>\n</ul>\n<h3 id=\"如何停止一个Promise链？\"><a href=\"#如何停止一个Promise链？\" class=\"headerlink\" title=\"如何停止一个Promise链？\"></a>如何停止一个Promise链？</h3><p>在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.cancel = <span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提问概率：50%（此问题主要考察面试者罗辑思维）</li>\n</ul>\n<h3 id=\"Promise链上返回的最后一个Promise出错了怎么办？\"><a href=\"#Promise链上返回的最后一个Promise出错了怎么办？\" class=\"headerlink\" title=\"Promise链上返回的最后一个Promise出错了怎么办？\"></a>Promise链上返回的最后一个Promise出错了怎么办？</h3><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">done</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;done&#x27;</span>, reason);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度）</li>\n<li>加分项：给出具体的done()方法代码</li>\n</ul>\n<h3 id=\"Promise存在哪些使用技巧或者最佳实践？\"><a href=\"#Promise存在哪些使用技巧或者最佳实践？\" class=\"headerlink\" title=\"Promise存在哪些使用技巧或者最佳实践？\"></a>Promise存在哪些使用技巧或者最佳实践？</h3><p>1、链式Promise要返回一个Promise，而不只是构造一个Promise。<br>2、合理的使用Promise.all和Promise.race等方法。<br>3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。</p>\n<ul>\n<li>提问概率：10%（出题概率极低的一个题目）</li>\n<li>加分项：越多越好</li>\n</ul>\n<p>参考链接：<br><a href=\"http://liubin.org/promises-book/\">http://liubin.org/promises-book</a><br><a href=\"https://github.com/xieranmaya/blog/issues/3\">https://github.com/xieranmaya/blog/issues/3</a><br><a href=\"https://segmentfault.com/a/1190000016550260\">https://segmentfault.com/a/1190000016550260</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>Javascript异步编程先后经历了四个阶段，分别是Callback阶段，Promise阶段，Generator阶段和Async/Await阶段。Callback很快就被发现存在回调地狱和控制权问题，Promise就是在这个时间出现，用以解决这些问题，Promise并非一个新事务，而是按照一个规范实现的类，这个规范有很多，如 Promise/A，Promise/B，Promise/D 以及 Promise/A 的升级版 Promise/A+，最终 ES6 中采用了 <a href=\"https://promisesaplus.com/\">Promise/A+</a> 规范。后来出现的Generator函数以及Async函数也是以Promise为基础的进一步封装，可见Promise在异步编程中的重要性。   </p>\n<p>关于Promise的资料已经很多，但每个人理解都不一样，不同的思路也会有不一样的收获。这篇文章会着重写一下Promise的实现以及笔者在日常使用过程中的一些心得体会。</p>","more":"<h2 id=\"实现Promise\"><a href=\"#实现Promise\" class=\"headerlink\" title=\"实现Promise\"></a>实现Promise</h2><h3 id=\"规范解读\"><a href=\"#规范解读\" class=\"headerlink\" title=\"规范解读\"></a>规范解读</h3><p><a href=\"https://promisesaplus.com/\">Promise/A+</a>规范主要分为术语、要求和注意事项三个部分，我们重点看一下第二部分也就是要求部分，以笔者的理解大概说明一下，具体细节参照完整版<a href=\"https://promisesaplus.com/\">Promise/A+</a>标准。</p>\n<blockquote>\n<p>1、<code>Promise</code>有三种状态<code>pending</code>，<code>fulfilled</code>和<code>rejected</code>。（为了一致性，此文章称<code>fulfilled</code>状态为<code>resolved</code>状态）</p>\n<blockquote>\n<ul>\n<li>状态转换只能是<code>pending</code>到<code>resolved</code>或者<code>pending</code>到<code>rejected</code>；</li>\n<li>状态一旦转换完成，不能再次转换。</li>\n</ul>\n</blockquote>\n<p>2、Promise拥有一个then方法，用以处理<code>resolved</code>或<code>rejected</code>状态下的值。</p>\n<blockquote>\n<ul>\n<li>then方法接收两个参数onFulfilled和onRejected，如果这两个参数不是函数，将会被忽略，并且这两个参数都是可选的。</li>\n<li>then方法必须返回一个新的Promise，记作promise2，这也就保证了then方法可以在同一个Promise上多次调用。（ps：规范只要求返回promise，并没有明确要求返回一个新的promise，这里为了跟ES6实现保持一致，我们也返回一个新promise）<ul>\n<li>onResolved/onRejected有返回值则把返回值定义为x，并执行[[Resolve]](promise2, x);</li>\n<li>onResolved/onRejected运行出错，则把promise2设置为<code>rejected</code>状态；</li>\n<li>onResolved/onRejected不是函数，则需要把promise1的状态传递下去。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>3、不同的Promise实现可以的交互。</p>\n<blockquote>\n<ul>\n<li>规范中称这一步操作为Promise解决过程，函数标示为[[Resolve]](promise, x)，promise为要返回的新promise对象，x为onResolved/onRejected的返回值。如果x有then方法且看上去像一个promise，我们就把x当成一个Promise的对象，即thenable对象，这种情况下尝试让promise接收x的状态。如果x不是thenable对象，就用x的值来执行 promise。</li>\n<li>[[Resolve]](promise, x)函数具体运行规则：<ul>\n<li>如果 promise 和 x 指向同一对象，以 TypeError 为据因拒绝执行 promise;</li>\n<li>如果 x 为 Promise ，则使 promise 接受 x 的状态;</li>\n<li>如果 x 为对象或者函数，取x.then的值，如果取值时出现错误，则让promise进入<code>rejected</code>状态，如果then不是函数，同样让promise进入<code>rejected</code>状态，如果then存在并且为函数，则把x作为then函数的作用域this调用，then方法接收两个参数，resolvePromise和rejectPromise，如果resolvePromise被执行，则以resolvePromise的参数value作为x继续调用[[Resolve]](promise, value)，直到x不是对象或者函数，如果rejectPromise被执行则让promise进入<code>rejected</code>状态；</li>\n<li>如果 x 不是对象或者函数，直接就用x的值来执行promise。</li>\n</ul>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><p>规范解读第1条，代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义Promise状态变量，初始值为pending</span></span><br><span class=\"line\">  status = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class=\"line\">  data = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">executor</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve函数负责把状态转换为resolved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// reject函数负责把状态转换为rejected</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = reason;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      executor(resolve, reject);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>规范解读第2条，代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">  * 拥有一个then方法</span></span><br><span class=\"line\"><span class=\"comment\">  * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class=\"line\"><span class=\"comment\">  * 返回一个新的Promise</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">onResolved, onRejected</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class=\"line\">  onResolved = <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">&#x27;function&#x27;</span> ? onResolved : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123; <span class=\"keyword\">return</span> e &#125;;</span><br><span class=\"line\">  onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span> ? onRejected : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">throw</span> e &#125;;</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise2;</span><br><span class=\"line\">  </span><br><span class=\"line\">  promise2 =  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 如果状态为resolved，则执行onResolved</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onResolved(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">        <span class=\"comment\">// 执行[[Resolve]](promise2, x)</span></span><br><span class=\"line\">        resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果状态为rejected，则执行onRejected</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> x = onRejected(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">        resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在我们就按照规范解读第2条，实现了上述代码，上述代码很明显是有问题的，问题如下</p>\n<ol>\n<li>resolvePromise未定义；</li>\n<li>then方法执行的时候，promise可能仍然处于<code>pending</code>状态，因为<code>executor</code>中可能存在异步操作（实际情况大部分为异步操作），这样就导致onResolved/onRejected失去了执行时机；</li>\n<li>onResolved/onRejected这两相函数需要异步调用;(官方Promise实现的回调函数总是异步调用的)</li>\n</ol>\n<p>解决办法：</p>\n<ol>\n<li>根据规范解读第3条，定义并实现resolvePromise函数；</li>\n<li>then方法执行时如果promise仍然处于<code>pending</code>状态，则把处理函数进行储存，等resolve/reject函数真正执行的的时候再调用。</li>\n<li>Promise属于微任务，这里我们为了方便，用宏任务setTiemout来代替实现异步，具体细节特别推荐<a href=\"https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA\">这篇文章</a>。</li>\n</ol>\n<p>好了，有了解决办法，我们就把代码进一步完善：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Promise</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 定义Promise状态变量，初始值为pending</span></span><br><span class=\"line\">  status = <span class=\"string\">&#x27;pending&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// 因为在then方法中需要处理Promise成功或失败时的值，所以需要一个全局变量存储这个值</span></span><br><span class=\"line\">  data = <span class=\"string\">&#x27;&#x27;</span>;</span><br><span class=\"line\">  <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">  onResolvedCallback = [];</span><br><span class=\"line\">  <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">  onRejectedCallback = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// Promise构造函数，传入参数为一个可执行的函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">constructor</span>(<span class=\"params\">executor</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// resolve函数负责把状态转换为resolved</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;resolved&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = value;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> func <span class=\"keyword\">of</span> <span class=\"built_in\">this</span>.onResolvedCallback) &#123;</span><br><span class=\"line\">        func(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// reject函数负责把状态转换为rejected</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">reject</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;rejected&#x27;</span>;</span><br><span class=\"line\">      <span class=\"built_in\">this</span>.data = reason;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> func <span class=\"keyword\">of</span> <span class=\"built_in\">this</span>.onRejectedCallback) &#123;</span><br><span class=\"line\">        func(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 直接执行executor函数，参数为处理函数resolve, reject。因为executor执行过程有可能会出错，错误情况需要执行reject</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      executor(resolve, reject);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">      reject(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    * 拥有一个then方法</span></span><br><span class=\"line\"><span class=\"comment\">    * then方法提供：状态为resolved时的回调函数onResolved，状态为rejected时的回调函数onRejected</span></span><br><span class=\"line\"><span class=\"comment\">    * 返回一个新的Promise</span></span><br><span class=\"line\"><span class=\"comment\">  */</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">then</span>(<span class=\"params\">onResolved, onRejected</span>)</span> &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 设置then的默认参数，默认参数实现Promise的值的穿透</span></span><br><span class=\"line\">    onResolved = <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">&#x27;function&#x27;</span> ? onResolved : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">v</span>) </span>&#123; <span class=\"keyword\">return</span> e &#125;;</span><br><span class=\"line\">    onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">&#x27;function&#x27;</span> ? onRejected : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">e</span>) </span>&#123; <span class=\"keyword\">throw</span> e &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> promise2;</span><br><span class=\"line\"></span><br><span class=\"line\">    promise2 =  <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果状态为resolved，则执行onResolved</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;resolved&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">// onResolved/onRejected有返回值则把返回值定义为x</span></span><br><span class=\"line\">            <span class=\"keyword\">const</span> x = onResolved(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">            <span class=\"comment\">// 执行[[Resolve]](promise2, x)</span></span><br><span class=\"line\">            <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果状态为rejected，则执行onRejected</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status === <span class=\"string\">&#x27;rejected&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> x = onRejected(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">            reject(e);</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\">// 如果状态为pending，则把处理函数进行存储</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.status = <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"built_in\">this</span>.onResolvedCallback.push(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> x = onResolved(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">              <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">              reject(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">this</span>.onRejectedCallback.push(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">              <span class=\"keyword\">const</span> x = onRejected(<span class=\"built_in\">this</span>.data);</span><br><span class=\"line\">              <span class=\"built_in\">this</span>.resolvePromise(promise2, x, resolve, reject);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">              reject(e);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">          &#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// [[Resolve]](promise2, x)函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>至此，规范中关于then的部分就全部实现完毕了。</p>\n<p>规范解读第3条，代码实现：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// [[Resolve]](promise2, x)函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"title\">resolvePromise</span>(<span class=\"params\">promise2, x, resolve, reject</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> called = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (promise2 === x) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> reject(<span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&#x27;Chaining cycle detected for promise!&#x27;</span>))</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 如果x仍然为Promise的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 如果x的状态还没有确定，那么它是有可能被一个thenable决定最终状态和值，所以需要继续调用resolvePromise</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (x.status === <span class=\"string\">&#x27;pending&#x27;</span>) &#123;</span><br><span class=\"line\">        x.then(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">          resolvePromise(promise2, value, resolve, reject)</span><br><span class=\"line\">        &#125;, reject)</span><br><span class=\"line\">      &#125; <span class=\"keyword\">else</span> &#123; </span><br><span class=\"line\">        <span class=\"comment\">// 如果x状态已经确定了，直接取它的状态</span></span><br><span class=\"line\">        x.then(resolve, reject)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> (x !== <span class=\"literal\">null</span> &amp;&amp; (<span class=\"built_in\">Object</span>.prototype.toString(x) === <span class=\"string\">&#x27;[object Object]&#x27;</span> || <span class=\"built_in\">Object</span>.prototype.toString(x) === <span class=\"string\">&#x27;[object Function]&#x27;</span>)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 因为x.then有可能是一个getter，这种情况下多次读取就有可能产生副作用，所以通过变量called进行控制</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> then = x.then </span><br><span class=\"line\">        <span class=\"comment\">// then是函数，那就说明x是thenable，继续执行resolvePromise函数，直到x为普通值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> then === <span class=\"string\">&#x27;function&#x27;</span>) &#123; </span><br><span class=\"line\">          then.call(x, <span class=\"function\">(<span class=\"params\">y</span>) =&gt;</span> &#123; </span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            <span class=\"built_in\">this</span>.resolvePromise(promise2, y, resolve, reject);</span><br><span class=\"line\">          &#125;, <span class=\"function\">(<span class=\"params\">r</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">            called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            reject(r);</span><br><span class=\"line\">          &#125;)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">// 如果then不是函数，那就说明x不是thenable，直接resolve x</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span> ;</span><br><span class=\"line\">          called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          resolve(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (called) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        called = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        reject(e);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      resolve(x);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>这一步骤非常简单，只要按照规范转换成代码即可。</p>\n<p>最后，完整的Promise按照规范就实现完毕了，是的，规范里并没有规定catch、Promise.resolve、Promise.reject、Promise.all等方法，接下来，我们就看一看Promise的这些常用方法。</p>\n<h3 id=\"Promise其他方法实现\"><a href=\"#Promise其他方法实现\" class=\"headerlink\" title=\"Promise其他方法实现\"></a>Promise其他方法实现</h3><h4 id=\"1、catch方法\"><a href=\"#1、catch方法\" class=\"headerlink\" title=\"1、catch方法\"></a>1、catch方法</h4><p>catch方法是对then方法的封装，只用于接收reject(reason)中的错误信息。因为在then方法中onRejected参数是可不传的，不传的情况下，错误信息会依次往后传递，直到有onRejected函数接收为止，因此在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">catch</span>(onRejected) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.then(<span class=\"literal\">null</span>, onRejected);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"2、done方法\"><a href=\"#2、done方法\" class=\"headerlink\" title=\"2、done方法\"></a>2、done方法</h4><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">done</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;done&#x27;</span>, reason);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"3、finally方法\"><a href=\"#3、finally方法\" class=\"headerlink\" title=\"3、finally方法\"></a>3、finally方法</h4><p>finally方法用于无论是resolve还是reject，finally的参数函数都会被执行。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">finally</span>(<span class=\"params\">fn</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">this</span>.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;, <span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    fn();</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"4、Promise-all方法\"><a href=\"#4、Promise-all方法\" class=\"headerlink\" title=\"4、Promise.all方法\"></a>4、Promise.all方法</h4><p>Promise.all方法接收一个promise数组，返回一个新promise2，并发执行数组中的全部promise，所有promise状态都为<code>resolved</code>时，promise2状态为<code>resolved</code>并返回全部promise结果，结果顺序和promise数组顺序一致。如果有一个promise为rejected状态，则整个promise2为rejected。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">all</span>(<span class=\"params\">promiseList</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> result = [];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> i = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> p <span class=\"keyword\">of</span> promiseList) &#123;</span><br><span class=\"line\">      p.then(<span class=\"function\"><span class=\"params\">value</span> =&gt;</span> &#123;</span><br><span class=\"line\">        result[i] = value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (result.length === promiseList.length) &#123;</span><br><span class=\"line\">          resolve(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;, reject);</span><br><span class=\"line\">      i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"5、Promise-race方法\"><a href=\"#5、Promise-race方法\" class=\"headerlink\" title=\"5、Promise.race方法\"></a>5、Promise.race方法</h4><p>Promise.race方法接收一个promise数组, 返回一个新promise2，顺序执行数组中的promise，有一个promise状态确定，promise2状态即确定，并且同这个promise的状态一致。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">race</span>(<span class=\"params\">promiseList</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> p <span class=\"keyword\">of</span> promiseList) &#123;</span><br><span class=\"line\">      p.then(<span class=\"function\">(<span class=\"params\">value</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        resolve(value);   </span><br><span class=\"line\">      &#125;, reject);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"6、Promise-resolve方法-Promise-reject\"><a href=\"#6、Promise-resolve方法-Promise-reject\" class=\"headerlink\" title=\"6、Promise.resolve方法/Promise.reject\"></a>6、Promise.resolve方法/Promise.reject</h4><p>Promise.resolve用来生成一个fulfilled完成态的Promise，Promise.reject用来生成一个rejected失败态的Promise。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">resolve</span>(<span class=\"params\">value</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> promise;</span><br><span class=\"line\"></span><br><span class=\"line\">  promise = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">this</span>.resolvePromise(promise, value, resolve, reject);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> promise;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"function\"><span class=\"title\">reject</span>(<span class=\"params\">reason</span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    reject(reason);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>常用的方法基本就这些，Promise还有很多扩展方法，这里就不一一展示，基本上都是对then方法的进一步封装，只要你的then方法没有问题，其他方法就都可以依赖then方法实现。</p>\n<h2 id=\"Promise面试相关\"><a href=\"#Promise面试相关\" class=\"headerlink\" title=\"Promise面试相关\"></a>Promise面试相关</h2><p>面试相关问题，笔者只说一下我司这几年的情况，并不能代表全部情况，参考即可。<br>Promise是我司前端开发职位，nodejs开发职位，全栈开发职位，必问的一个知识点，大题情况会分布在Promise介绍、基础使用方法以及深层次的理解三个方面，问题一般在3-5个，根据面试者回答情况会适当增减。</p>\n<h3 id=\"简单介绍下Promise。\"><a href=\"#简单介绍下Promise。\" class=\"headerlink\" title=\"简单介绍下Promise。\"></a>简单介绍下Promise。</h3><p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。<br>（当然了也可以简单介绍promise状态，有什么方法，这个问题是比较开放的）</p>\n<ul>\n<li>提问概率：99%</li>\n<li>评分标准：人性化判断即可，此问题一般作为引入问题。</li>\n<li>加分项：熟练说出Promise具体解决了那些问题，存在什么缺点，应用方向等等。</li>\n</ul>\n<h3 id=\"实现一个简单的，支持异步链式调用的Promise类。\"><a href=\"#实现一个简单的，支持异步链式调用的Promise类。\" class=\"headerlink\" title=\"实现一个简单的，支持异步链式调用的Promise类。\"></a>实现一个简单的，支持异步链式调用的Promise类。</h3><p>这个答案不是固定的，可以参考<a href=\"https://juejin.cn/post/6844904094079926286\">最简实现 Promise，支持异步链式调用</a></p>\n<ul>\n<li>提问概率：50%（手撸代码题，因为这类题目比较耗费时间，一场面试并不会出现很多，所以出现频率不是很高，但却是必备知识）</li>\n<li>加分项：onResolved/onRejected函数异步调用，错误捕获合理等</li>\n</ul>\n<h3 id=\"Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序\"><a href=\"#Promise-then在Event-Loop中的执行顺序。-可以直接问，也可以出具体题目让面试者回答打印顺序\" class=\"headerlink\" title=\"Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)\"></a>Promise.then在Event Loop中的执行顺序。(可以直接问，也可以出具体题目让面试者回答打印顺序)</h3><p>JS中分为两种任务类型：macrotask和microtask，其中macrotask包含：主代码块，setTimeout，setInterval，setImmediate等（setImmediate规定：在下一次Event Loop（宏任务）时触发），microtask包含：Promise，process.nextTick等（在node环境下，process.nextTick的优先级高于Promise）<br>Event Loop中执行一个macrotask任务（栈中没有就从事件队列中获取）执行过程中如果遇到microtask任务，就将它添加到微任务的任务队列中，macrotask任务执行完毕后，立即执行当前微任务队列中的所有microtask任务（依次执行），然后开始下一个macrotask任务（从事件队列中获取）<br>浏览器运行机制可参考<a href=\"https://mp.weixin.qq.com/s/vIKDUrbuxVNQMi_g_fiwUA\">这篇文章</a></p>\n<ul>\n<li>提问概率：75%（可以理解为4次面试中3次会问到，顺便可以考察面试者对JS运行机制的理解）</li>\n<li>加分项：扩展讲述浏览器运行机制。</li>\n</ul>\n<h3 id=\"阐述Promise的一些方法。\"><a href=\"#阐述Promise的一些方法。\" class=\"headerlink\" title=\"阐述Promise的一些方法。\"></a>阐述Promise的一些方法。</h3><p>Promise.deferred、Promise.all、Promise.race、Promise.resolve、Promise.reject等</p>\n<ul>\n<li>提问概率：25%</li>\n<li>加分项：越多越好</li>\n</ul>\n<h3 id=\"Promise存在哪些缺点。\"><a href=\"#Promise存在哪些缺点。\" class=\"headerlink\" title=\"Promise存在哪些缺点。\"></a>Promise存在哪些缺点。</h3><p>1、无法取消Promise，一旦新建它就会立即执行，无法中途取消。<br>2、如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。<br>3、吞掉错误或异常，错误只能顺序处理，即便在Promise链最后添加catch方法，依然可能存在无法不做的错误（catch内部可能会出现错误）<br>4、阅读代码不是一眼可以看懂，你只会看到一堆then，必须自己在then的回调函数里面理清逻辑。</p>\n<ul>\n<li>提问概率：25%（此问题作为提高题目，出现概率不高）</li>\n<li>加分项：越多越合理越好</li>\n</ul>\n<h3 id=\"使用Promise进行顺序（sequence）处理。\"><a href=\"#使用Promise进行顺序（sequence）处理。\" class=\"headerlink\" title=\"使用Promise进行顺序（sequence）处理。\"></a>使用Promise进行顺序（sequence）处理。</h3><p>1、使用async函数配合await或者使用generator函数配合yield。<br>2、使用promise.then通过for循环或者Array.prototype.reduce实现。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sequenceTasks</span>(<span class=\"params\">tasks</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">recordValue</span>(<span class=\"params\">results, value</span>) </span>&#123;</span><br><span class=\"line\">        results.push(value);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> results;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> pushValue = recordValue.bind(<span class=\"literal\">null</span>, []);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks.reduce(<span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">promise, task</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> promise.then(<span class=\"function\">() =&gt;</span> task).then(pushValue);</span><br><span class=\"line\">    &#125;, <span class=\"built_in\">Promise</span>.resolve());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提问概率：90%（我司提问概率极高的题目，技能考察面试者对promise的理解程度，又能考察变成逻辑，最后还有bind和reduce等方法的运用）</li>\n<li>评分标准：说出任意解决方法即可，其中只能说出async函数和generator函数的可以得到20%的分数，可以用promise.then配合for循环解决的可以得到40%的分数，配合Array.prototype.reduce实现的可以得到最后的40%分数。</li>\n</ul>\n<h3 id=\"如何停止一个Promise链？\"><a href=\"#如何停止一个Promise链？\" class=\"headerlink\" title=\"如何停止一个Promise链？\"></a>如何停止一个Promise链？</h3><p>在要停止的promise链位置添加一个方法，返回一个永远不执行resolve或者reject的Promise，那么这个Promise永远处于pending状态，所以永远也不会向下执行then或catch了。这样我们就停止了一个Promise链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.cancel = <span class=\"built_in\">Promise</span>.stop = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提问概率：50%（此问题主要考察面试者罗辑思维）</li>\n</ul>\n<h3 id=\"Promise链上返回的最后一个Promise出错了怎么办？\"><a href=\"#Promise链上返回的最后一个Promise出错了怎么办？\" class=\"headerlink\" title=\"Promise链上返回的最后一个Promise出错了怎么办？\"></a>Promise链上返回的最后一个Promise出错了怎么办？</h3><p>catch在Promise链式调用的末尾调用，用于捕获链条中的错误信息，但是catch方法内部也可能出现错误，所以有些Promise实现中增加了一个方法done，done相当于提供了一个不会出错的catch方法，并且不再返回一个Promise，一般用来结束一个Promise链。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">done</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&#x27;done&#x27;</span>, reason);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> reason;</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>提问概率：90%（同样作为出题率极高的一个题目，充分考察面试者对promise的理解程度）</li>\n<li>加分项：给出具体的done()方法代码</li>\n</ul>\n<h3 id=\"Promise存在哪些使用技巧或者最佳实践？\"><a href=\"#Promise存在哪些使用技巧或者最佳实践？\" class=\"headerlink\" title=\"Promise存在哪些使用技巧或者最佳实践？\"></a>Promise存在哪些使用技巧或者最佳实践？</h3><p>1、链式Promise要返回一个Promise，而不只是构造一个Promise。<br>2、合理的使用Promise.all和Promise.race等方法。<br>3、在写Promise链式调用的时候，then方法不传onRejected函数，只需要在最末尾加一个catch()就可以了，这样在该链条中的Promise发生的错误都会被最后的catch捕获到。如果catch()代码有出现错误的可能，需要在链式调用的末尾增加done()函数。</p>\n<ul>\n<li>提问概率：10%（出题概率极低的一个题目）</li>\n<li>加分项：越多越好</li>\n</ul>\n<p>参考链接：<br><a href=\"http://liubin.org/promises-book/\">http://liubin.org/promises-book</a><br><a href=\"https://github.com/xieranmaya/blog/issues/3\">https://github.com/xieranmaya/blog/issues/3</a><br><a href=\"https://segmentfault.com/a/1190000016550260\">https://segmentfault.com/a/1190000016550260</a></p>"},{"title":"Redis应用实战 - 秒杀场景（Node.js版本）","date":"2021-06-25T09:07:25.000Z","_content":"\n## 写在前面\n公司随着业务量的增加，最近用时几个月时间在项目中全面接入`Redis`，开发过程中发现市面上缺少具体的实战资料，尤其是在`Node.js`环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍`Redis`的几个使用场景，期望大家一起学习、进步。   \n下面就开始第一篇，秒杀场景。\n## 业务分析\n实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下：\n\n1. 秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用`CDN`或者是浏览器进行缓存。\n1. 秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是\n    - 短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高）\n    - 请求数量大于商品库存，比如10000个用户抢购，但是库存只有100\n    - 限定用户只能在一定时间段内购买\n    - 限制单个用户购买数量，避免刷单\n    - 抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数\n    - 对数据库的操作读多写少，而且读操作相对简单\n    \n1. 秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。\n\n根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。\n    \n## 开发环境\n数据库：`Redis 3.2.9` + `Mysql 5.7.18`\n服务器：`Node.js v10.15.0`\n测试工具：`Jmeter-5.4.1`\n\n<!--more-->\n\n## 实战\n### 数据库准备\n![tables](media/16239877134495/tables.jpg)\n如图所示，`Mysql`中需要创建三张表，分别是\n\n- 产品表，用于记录产品信息，字段分别为Id、名称、缩略图、价格和状态等等\n- 秒杀活动表，用于记录秒杀活动的详细信息，字段分别为Id、参与秒杀的产品Id、库存量、秒杀开始时间、秒杀结束时间和秒杀活动是否有效等等\n- 订单表，用于记录下单后的数据，字段分别为Id、订单号、产品Id、购买用户Id、订单状态、订单类型和秒杀活动Id等等\n\n下面是创建`sql`语句，以供参考\n\n```sql\nCREATE TABLE `scekill_goods` (\n\t`id` INTEGER NOT NULL auto_increment,\n\t`fk_good_id` INTEGER,\n\t`amount` INTEGER,\n\t`start_time` DATETIME,\n\t`end_time` DATETIME,\n\t`is_valid` TINYINT ( 1 ),\n\t`comment` VARCHAR ( 255 ),\n\t`created_at` DATETIME NOT NULL,\n\t`updated_at` DATETIME NOT NULL,\nPRIMARY KEY ( `id` ) \n) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;\n```\n\n\n```sql\nCREATE TABLE `orders` (\n\t`id` INTEGER NOT NULL auto_increment,\n\t`order_no` VARCHAR ( 255 ),\n\t`good_id` INTEGER,\n\t`user_id` INTEGER,\n\t`status` ENUM ( '-1', '0', '1', '2' ),\n\t`order_type` ENUM ( '1', '2' ),\n\t`scekill_id` INTEGER,\n\t`comment` VARCHAR ( 255 ),\n\t`created_at` DATETIME NOT NULL,\n\t`updated_at` DATETIME NOT NULL,\nPRIMARY KEY ( `id` ) \n) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;\n```\n\n\n```sql\nCREATE TABLE `goods` (\n\t`id` INTEGER NOT NULL auto_increment,\n\t`name` VARCHAR ( 255 ),\n\t`thumbnail` VARCHAR ( 255 ),\n\t`price` INTEGER,\n\t`status` TINYINT ( 1 ),\n\t`stock` INTEGER,\n\t`stock_left` INTEGER,\n\t`description` VARCHAR ( 255 ),\n\t`comment` VARCHAR ( 255 ),\n\t`created_at` DATETIME NOT NULL,\n\t`updated_at` DATETIME NOT NULL,\nPRIMARY KEY ( `id` ) \n) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;\n```\n  \n产品表在此次业务中不是重点，以下逻辑都以`id=1`的产品为示例，请悉知。   \n秒杀活动表中创建一条库存为200的记录，作为秒杀测试数据，参考下面语句：\n\n```sql\nINSERT INTO `redis_app`.`seckill_goods` (\n\t`id`,\n\t`fk_good_id`,\n\t`amount`,\n\t`start_time`,\n\t`end_time`,\n\t`is_valid`,\n\t`comment`,\n\t`created_at`,\n\t`updated_at` \n)\nVALUES\n\t(\n\t\t1,\n\t\t1,\n\t\t200,\n\t\t'2020-06-20 00:00:00',\n\t\t'2023-06-20 00:00:00',\n\t\t1,\n\t\t'...',\n\t\t'2020-06-20 00:00:00',\n\t\t'2021-06-22 10:18:16' \n\t);\n```\n\n### 秒杀接口开发\n首先，说一下`Node.js`中的具体开发环境:\n\n- `web`框架使用`Koa2`\n- `mysql`操作使用基于`promise`的`Node.js` `ORM`工具`Sequelize`\n- `redis`操作使用`ioredis`库\n- 封装`ctx.throwException`方法用于处理错误，封装`ctx.send`方法用于返回正确结果，具体实现参考文末完整代码\n\n其次，分析一下接口要处理的逻辑，大概步骤和顺序如下：\n\n1. 基本参数校验\n1. 判断产品是否加入了抢购\n1. 判断秒杀活动是否有效\n1. 判断秒杀活动是否开始、结束\n1. 判断秒杀商品是否卖完\n1. 获取登录用户信息\n1. 判断登录用户是否已抢到\n1. 扣库存\n1. 下单\n\n最后，根据分析把以上步骤用代码进行初步实现，如下：\n\n```js\n// 引入moment库处理时间相关数据\nconst moment = require('moment');\n// 引入数据库model文件\nconst seckillModel = require('../../dbs/mysql/models/seckill_goods');\nconst ordersModel = require('../../dbs/mysql/models/orders');\n// 引入工具函数或工具类\nconst UserModule = require('../modules/user');\nconst { random_String } = require('../../utils/tools/funcs');\n\nclass Seckill {\n  /**\n   * 秒杀接口\n   * \n   * @method post\n   * @param good_id 产品id\n   * @param accessToken 用户Token\n   * @param path 秒杀完成后跳转路径\n   */\n  async doSeckill(ctx, next) {\n    const body = ctx.request.body;\n    const accessToken = ctx.query.accessToken;\n    const path = body.path;\n\n    // 基本参数校验\n    if (!accessToken || !path) { return ctx.throwException(20001, '参数错误！'); };\n    // 判断此产品是否加入了抢购\n    const seckill = await seckillModel.findOne({\n      where: {\n        fk_good_id: ctx.params.good_id,\n      }\n    });\n    if (!seckill) { return ctx.throwException(30002, '该产品并未有抢购活动！'); };\n    // 判断是否有效\n    if (!seckill.is_valid) { return ctx.throwException(30003, '该活动已结束！'); };\n    // 判单是否开始、结束\n    if(moment().isBefore(moment(seckill.start_time))) {\n      return ctx.throwException(30004, '该抢购活动还未开始！');\n    }\n    if(moment().isAfter(moment(seckill.end_time))) {\n      return ctx.throwException(30005, '该抢购活动已经结束！');\n    }\n    // 判断是否卖完\n    if(seckill.amount < 1) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n    //获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的accessToken校验流程)\n    const userInfo = await UserModule.getUserInfo(accessToken);\n    if (!userInfo) { return ctx.throwException(10002, '用户不存在！'); };\n\n    // 判断登录用户是否已抢到（一个用户针对这次活动只能购买一次）\n    const orderInfo = await ordersModel.findOne({\n      where: {\n        user_id: userInfo.id,\n        seckill_id: seckill.id,\n      },\n    });\n    if (orderInfo) { return ctx.throwException(30007, '该用户已抢到该产品，无需再抢！'); };\n\n    // 扣库存\n    const count = await seckill.decrement('amount');\n    if (count.amount <= 0) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n    // 下单\n    const orderData = {\n      order_no: Date.now() + random_String(4), // 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 \n      good_id: ctx.params.good_id,\n      user_id: userInfo.id,\n      status: '1', // -1 已取消, 0 未付款， 1 已付款， 2已退款\n      order_type: '2', // 1 常规订单 2 秒杀订单\n      seckill_id: seckill.id, // 秒杀活动id\n      comment: '', // 备注\n    };\n    const order = ordersModel.create(orderData);\n\n    if (!order) { return ctx.throwException(30008, '抢购失败!'); };\n\n    ctx.send({\n      path,\n      data: '抢购成功!'\n    });\n\n  }\n\n}\n\nmodule.exports = new Seckill();\n```\n\n至此，秒杀接口用传统的关系型数据库就实现完成了，代码并不复杂，注释也很详细，不用特别的讲解大家也都能看懂，那它能不能正常工作呢，答案显然是否定的   \n通过`Jmeter`模拟以下测试：\n\n- 模拟5000并发下2000个用户进行秒杀，会发现`mysql`报出`timeout`错误，同时`seckill_goods`表`amount`字段变成负数，`orders`表中同样产生了多于200的记录（具体数据不同环境下会有差异），这就代表产生了超卖，跟秒杀规则不符\n- 模拟10000并发下单个用户进行秒杀，`orders`表中产生了多于1条的记录（具体数据不同环境下会有差异），这就说明一个用户针对这次活动买了多次，跟秒杀规则不符\n\n\n分析下代码会发现这其中的问题：\n\n- 步骤2，判断此产品是否加入了抢购   \n\n    直接在`mysql`中查询，因为是在秒杀场景下，并发会很高，大量的请求到数据库，显然mysql是扛不住的，毕竟`mysql`每秒只能支撑千级别的并发请求\n- 步骤7，判断登录用户是否已抢到   \n\n    在高并发下同一个用户上个订单还没有生成成功，再次判断是否抢到依然会判断为否，这种情况下代码并没有对扣减和下单操作做任何限制，因此就产生了单个用户购买多个产品的情况，跟一个用户针对这次活动只能购买一次的要求不符\n- 步骤8，扣库存操作   \n    \n    假设同时有1000个请求，这1000个请求在步骤5判断产品是否秒杀完的时候查询到的库存都是200，因此这些请求都会执行步骤8扣减库存，那库存肯定会变成负数，也就是产生了超卖现象\n\n\n\n### 解决方案\n经过分析得到三个问题需要解决：\n\n1. 秒杀数据需要支持高并发访问\n2. 一个用户针对这次活动只能购买一次的问题，也就是限购问题\n3. 减库存不能扣成负数，订单数不能超过设置的库存数，也就是超卖问题\n\n`Redis`作为内存型数据库，本身高速处理请求的特性可以支持高并发。针对超卖，也就是库存扣减变负数情况，`Redis`可以提供`Lua`脚本保证原子性和分布式锁两个解决高并发下数据不一致的问题。针对一个用户只能购买一次的要求，`Redis`的分布式锁可以解决问题。   \n因此，可以尝试用Redis解决上述问题，具体操作：\n\n- 为了支撑大量高并发的库存查验请求，需要用`Redis`保存秒杀活动数据（即`seckill_goods`表数据），这样一来请求可以直接从`Redis`中读取库存并进行查询，完成查询之后如果还有库存余量，就直接从`Redis`中扣除库存\n- 扣减库存操作在`Redis`中进行，但是因为`Redis`扣减这一操作是分为读和写两个步骤，也就是必须先读数据进行判断再执行减操作，因此如果对这两个操作没有做好控制，就导致数据被改错，依然会出现超卖现象，为了保证并发访问的正确性需要使用原子操作解决问题，`Redis`提供了使用`Lua`脚本包含多个操作来实现原子性的方案   \n以下是`Redis`官方文档对`Lua`脚本原子性的解释\n\n    >Atomicity of scripts\n    Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.\n    \n- 使用`Redis`实现分布式锁，对扣库存和写订单操作进行加锁，以保证一个用户只能购买一次的问题。\n    \n### 接入Redis\n首先，不再使用`seckill_goods`表，新增秒杀活动逻辑变为在`Redis`中插入数据，类型为`hash`类型，`key`规则为`seckill_good_ + 产品id`，现在假设新增一条`key`为`seckill_good_1`的记录，值为\n\n```js\n{\n    amount: 200,\n    start_time: '2020-06-20 00:00:00',\n    end_time: '2023-06-20 00:00:00',\n    is_valid: 1,\n    comment: '...',\n  }\n```\n其次，创建`lua`脚本保证扣减操作的原子性，脚本内容如下\n\n```lua\nif (redis.call('hexists', KEYS[1], KEYS[2]) == 1) then\n  local stock = tonumber(redis.call('hget', KEYS[1], KEYS[2]));\n  if (stock > 0) then\n    redis.call('hincrby',  KEYS[1], KEYS[2], -1);\n    return stock\n  end;\n  return 0\nend;\n```\n最后，完成代码，完整代码如下：\n\n```js\n// 引入相关库\nconst moment = require('moment');\nconst Op = require('sequelize').Op;\nconst { v4: uuidv4 } = require('uuid');\n// 引入数据库model文件\nconst seckillModel = require('../../dbs/mysql/models/seckill_goods');\nconst ordersModel = require('../../dbs/mysql/models/orders');\n// 引入Redis实例\nconst redis = require('../../dbs/redis');\n// 引入工具函数或工具类\nconst UserModule = require('../modules/user');\nconst { randomString, checkObjNull } = require('../../utils/tools/funcs');\n// 引入秒杀key前缀\nconst { SECKILL_GOOD, LOCK_KEY } = require('../../utils/constants/redis-prefixs');\n// 引入避免超卖lua脚本\nconst { stock, lock, unlock } = require('../../utils/scripts');\n\nclass Seckill {\n  async doSeckill(ctx, next) {\n    const body = ctx.request.body;\n    const goodId = ctx.params.good_id;\n    const accessToken = ctx.query.accessToken;\n    const path = body.path;\n\n    // 基本参数校验\n    if (!accessToken || !path) { return ctx.throwException(20001, '参数错误！'); };\n    // 判断此产品是否加入了抢购\n    const key = `${SECKILL_GOOD}${goodId}`;\n    const seckill = await redis.hgetall(key);\n    if (!checkObjNull(seckill)) { return ctx.throwException(30002, '该产品并未有抢购活动！'); };\n    // 判断是否有效\n    if (!seckill.is_valid) { return ctx.throwException(30003, '该活动已结束！'); };\n    // 判单是否开始、结束\n    if(moment().isBefore(moment(seckill.start_time))) {\n      return ctx.throwException(30004, '该抢购活动还未开始！');\n    }\n    if(moment().isAfter(moment(seckill.end_time))) {\n      return ctx.throwException(30005, '该抢购活动已经结束！');\n    }\n    // 判断是否卖完\n    if(seckill.amount < 1) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n    //获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的登录注册校验流程)\n    const userInfo = await UserModule.getUserInfo(accessToken);\n    if (!userInfo) { return ctx.throwException(10002, '用户不存在！'); };\n\n    // 判断登录用户是否已抢到\n    const orderInfo = await ordersModel.findOne({\n      where: {\n        user_id: userInfo.id,\n        good_id: goodId,\n        status: { [Op.between]: ['0', '1'] },\n      },\n    });\n    if (orderInfo) { return ctx.throwException(30007, '该用户已抢到该产品，无需再抢！'); };\n    \n    // 加锁，实现一个用户针对这次活动只能购买一次\n    const lockKey = `${LOCK_KEY}${userInfo.id}:${goodId}`; // 锁的key有用户id和商品id组成\n    const uuid = uuidv4();\n    const expireTime = moment(seckill.end_time).diff(moment(), 'minutes'); // 锁存在时间为当前时间和活动结束的时间差\n    const tryLock = await redis.eval(lock, 2, [lockKey, 'releaseTime', uuid, expireTime]);\n    \n    try {\n      if (tryLock === 1) {\n        // 扣库存\n        const count = await redis.eval(stock, 2, [key, 'amount', '', '']);\n        if (count <= 0) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n        // 下单\n        const orderData = {\n          order_no: Date.now() + randomString(4), // 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 \n          good_id: goodId,\n          user_id: userInfo.id,\n          status: '1', // -1 已取消, 0 未付款， 1 已付款， 2已退款\n          order_type: '2', // 1 常规订单 2 秒杀订单\n          // seckill_id: seckill.id, // 秒杀活动id, redis中不维护秒杀活动id\n          comment: '', // 备注\n        };\n        const order = ordersModel.create(orderData);\n\n        if (!order) { return ctx.throwException(30008, '抢购失败!'); };\n      }\n    } catch (e) {\n      await redis.eval(unlock, 1, [lockKey, uuid]);\n      return ctx.throwException(30006, '该产品已经卖完了！');\n    }\n\n    ctx.send({\n      path,\n      data: '抢购成功!'\n    });\n  }\n\n}\n\nmodule.exports = new Seckill();\n```\n\n这里代码主要做个四个修改：\n\n1. 步骤2，判断产品是否加入了抢购，改为去`Redis`中查询\n2. 步骤7，判断登录用户是否已抢到，因为不在维护抢购活动`id`，所以改为使用用户`id`、产品`id`和状态`status`判断\n3. 步骤8，扣库存，改为使用`lua`脚本去`Redis`中扣库存\n4. 对扣库存和写入数据库操作进行加锁\n\n订单的操作仍然在`Mysql`数据库中进行，因为大部分的请求都在步骤5被拦截了，剩余请求`Mysql`是完全有能力处理的。   \n\n再次通过`Jmeter`进行测试，发现订单表正常，库存量扣减正常，说明超卖问题和限购已经解决。\n\n\n## 其他问题\n1. 秒杀场景的其他技术\n    基于`Redis`支持高并发、键值对型数据库和支持原子操作等特点，案例中使用`Redis`来作为秒杀应对方案。在更复杂的秒杀场景下，除了使用`Redis`外，在必要的的情况下还需要用到其他一些技术：\n    \n    - 限流，用漏斗算法、令牌桶算法等进行限流\n    - 缓存，把热点数据缓存到内存里，尽可能缓解数据库访问的压力\n    - 削峰，使用消息队列和缓存技术使瞬间高流量转变成一段时间的平稳流量，比如客户抢购成功后，立即返回响应，然后通过消息队列异步处理后续步骤，发短信，写日志，更新一致性低的数据库等等\n    - 异步，假设商家创建一个只针对粉丝的秒杀活动，如果商家的粉丝比较少（假设小于1000），那么秒杀活动直接推送给所有粉丝，如果用户粉丝比较多，程序立刻推送给排名前1000的用户，其余用户采用消息队列延迟推送。（1000这个数字需要根据具体情况决定，比如粉丝数2000以内的商家占99%，只有1%的用户粉丝超过2000，那么这个值就应该设置为2000）\n    - 分流，单台服务器不行就上集群，通过负载均衡共同去处理请求，分散压力\n  \n    这些技术的应用会让整个秒杀系统更加完善，但是核心技术还是`Redis`，可以说用好`Redis`实现的秒杀系统就足以应对大部分场景。\n    \n2. `Redis`健壮性\n    案例使用的是单机版`Redis`，单节点在生产环境基本上不会使用，因为\n    - 不能达到高可用\n    - 即便有着`AOF`日志和`RDB`快照的解决方案以保证数据不丢失，但都只能放在`master`上，一旦机器故障，服务就无法运行，而且即便采取了相应措施仍不可避免的会造成数据丢失。\n    \n    因此，`Redis`的主从机制和集群机制在生产环境下是必须的。\n3. `Redis`分布式锁的问题\n    - 单点分布式锁，案例提到的分布式锁，实际上更准确的说法是单点分布式锁，是为了方便演示，但是，单点`Redis`分布式锁是肯定不能用在生产环境的，理由跟第2点类似\n    - 以主从机制（多机器）为基础的分布式锁，也是不够的，因为`redis`在进行主从复制时是异步完成的，比如在`clientA`获取锁后，主`redis`复制数据到从`redis`过程中崩溃了，导致锁没有复制到从`redis`中，然后从`redis`选举出一个升级为主`redis`，造成新的主`redis`没有`clientA`设置的锁，这时`clientB`尝试获取锁，并且能够成功获取锁，导致互斥失效。\n    \n    针对以上问题，`redis`官方设计了`Redlock`，在`Node.js`环境下对应的资源库为`node-redlock`，可以用`npm`安装，至少需要3个独立的服务器或集群才能使用，提供了非常高的容错率，在生产环境中应该优先采用此方案部署。\n\n## 总结\n秒杀场景的特点可以总结为瞬时并发访问、读多写少、限时和限量，开发中还要考虑避免超卖现象以及类似黄牛抢票的限购问题，针对以上特点和问题，分析得到开发的原则是：数据写入内存而不是写入硬盘，异步处理而不是同步处理，扣库存操作原子执行以及对单用户购买进行加锁，而`Redis`正好是符合以上全部特点的工具，因此最终选择`Redis`来解决问题。\n\n秒杀场景是一个在电商业务中相对复杂的场景，此篇文章只是介绍了其中最核心的逻辑，实际业务可能更加复杂，但只需要在此核心基础上进行扩展和优化即可。   \n秒杀场景的解决方案不仅仅适合秒杀，类似的还有抢红包、抢优惠券以及抢票等等，思路都是一致的。   \n解决方案的思路还可以应用在单独限购、第二件半价以及控制库存等等诸多场景，大家要灵活运用。\n\n## 项目地址\n\n[https://github.com/threerocks/redis-seckill](https://github.com/threerocks/redis-seckill)\n## 参考资料\n[https://time.geekbang.org/column/article/307421](https://time.geekbang.org/column/article/307421)\n[https://redis.io/topics/distlock](https://redis.io/topics/distlock)\n\n\n\n\n","source":"_posts/Redis应用实战 - 秒杀场景（Node.js版本）.md","raw":"---\ntitle: Redis应用实战 - 秒杀场景（Node.js版本）\ndate: 2021-06-25 17:07:25\ntags:\n- Node.js\n- Javascript\n- Mysql\n- Redis\n- 秒杀\n---\n\n## 写在前面\n公司随着业务量的增加，最近用时几个月时间在项目中全面接入`Redis`，开发过程中发现市面上缺少具体的实战资料，尤其是在`Node.js`环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍`Redis`的几个使用场景，期望大家一起学习、进步。   \n下面就开始第一篇，秒杀场景。\n## 业务分析\n实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下：\n\n1. 秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用`CDN`或者是浏览器进行缓存。\n1. 秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是\n    - 短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高）\n    - 请求数量大于商品库存，比如10000个用户抢购，但是库存只有100\n    - 限定用户只能在一定时间段内购买\n    - 限制单个用户购买数量，避免刷单\n    - 抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数\n    - 对数据库的操作读多写少，而且读操作相对简单\n    \n1. 秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。\n\n根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。\n    \n## 开发环境\n数据库：`Redis 3.2.9` + `Mysql 5.7.18`\n服务器：`Node.js v10.15.0`\n测试工具：`Jmeter-5.4.1`\n\n<!--more-->\n\n## 实战\n### 数据库准备\n![tables](media/16239877134495/tables.jpg)\n如图所示，`Mysql`中需要创建三张表，分别是\n\n- 产品表，用于记录产品信息，字段分别为Id、名称、缩略图、价格和状态等等\n- 秒杀活动表，用于记录秒杀活动的详细信息，字段分别为Id、参与秒杀的产品Id、库存量、秒杀开始时间、秒杀结束时间和秒杀活动是否有效等等\n- 订单表，用于记录下单后的数据，字段分别为Id、订单号、产品Id、购买用户Id、订单状态、订单类型和秒杀活动Id等等\n\n下面是创建`sql`语句，以供参考\n\n```sql\nCREATE TABLE `scekill_goods` (\n\t`id` INTEGER NOT NULL auto_increment,\n\t`fk_good_id` INTEGER,\n\t`amount` INTEGER,\n\t`start_time` DATETIME,\n\t`end_time` DATETIME,\n\t`is_valid` TINYINT ( 1 ),\n\t`comment` VARCHAR ( 255 ),\n\t`created_at` DATETIME NOT NULL,\n\t`updated_at` DATETIME NOT NULL,\nPRIMARY KEY ( `id` ) \n) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;\n```\n\n\n```sql\nCREATE TABLE `orders` (\n\t`id` INTEGER NOT NULL auto_increment,\n\t`order_no` VARCHAR ( 255 ),\n\t`good_id` INTEGER,\n\t`user_id` INTEGER,\n\t`status` ENUM ( '-1', '0', '1', '2' ),\n\t`order_type` ENUM ( '1', '2' ),\n\t`scekill_id` INTEGER,\n\t`comment` VARCHAR ( 255 ),\n\t`created_at` DATETIME NOT NULL,\n\t`updated_at` DATETIME NOT NULL,\nPRIMARY KEY ( `id` ) \n) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;\n```\n\n\n```sql\nCREATE TABLE `goods` (\n\t`id` INTEGER NOT NULL auto_increment,\n\t`name` VARCHAR ( 255 ),\n\t`thumbnail` VARCHAR ( 255 ),\n\t`price` INTEGER,\n\t`status` TINYINT ( 1 ),\n\t`stock` INTEGER,\n\t`stock_left` INTEGER,\n\t`description` VARCHAR ( 255 ),\n\t`comment` VARCHAR ( 255 ),\n\t`created_at` DATETIME NOT NULL,\n\t`updated_at` DATETIME NOT NULL,\nPRIMARY KEY ( `id` ) \n) ENGINE = INNODB DEFAULT CHARSET = utf8mb4;\n```\n  \n产品表在此次业务中不是重点，以下逻辑都以`id=1`的产品为示例，请悉知。   \n秒杀活动表中创建一条库存为200的记录，作为秒杀测试数据，参考下面语句：\n\n```sql\nINSERT INTO `redis_app`.`seckill_goods` (\n\t`id`,\n\t`fk_good_id`,\n\t`amount`,\n\t`start_time`,\n\t`end_time`,\n\t`is_valid`,\n\t`comment`,\n\t`created_at`,\n\t`updated_at` \n)\nVALUES\n\t(\n\t\t1,\n\t\t1,\n\t\t200,\n\t\t'2020-06-20 00:00:00',\n\t\t'2023-06-20 00:00:00',\n\t\t1,\n\t\t'...',\n\t\t'2020-06-20 00:00:00',\n\t\t'2021-06-22 10:18:16' \n\t);\n```\n\n### 秒杀接口开发\n首先，说一下`Node.js`中的具体开发环境:\n\n- `web`框架使用`Koa2`\n- `mysql`操作使用基于`promise`的`Node.js` `ORM`工具`Sequelize`\n- `redis`操作使用`ioredis`库\n- 封装`ctx.throwException`方法用于处理错误，封装`ctx.send`方法用于返回正确结果，具体实现参考文末完整代码\n\n其次，分析一下接口要处理的逻辑，大概步骤和顺序如下：\n\n1. 基本参数校验\n1. 判断产品是否加入了抢购\n1. 判断秒杀活动是否有效\n1. 判断秒杀活动是否开始、结束\n1. 判断秒杀商品是否卖完\n1. 获取登录用户信息\n1. 判断登录用户是否已抢到\n1. 扣库存\n1. 下单\n\n最后，根据分析把以上步骤用代码进行初步实现，如下：\n\n```js\n// 引入moment库处理时间相关数据\nconst moment = require('moment');\n// 引入数据库model文件\nconst seckillModel = require('../../dbs/mysql/models/seckill_goods');\nconst ordersModel = require('../../dbs/mysql/models/orders');\n// 引入工具函数或工具类\nconst UserModule = require('../modules/user');\nconst { random_String } = require('../../utils/tools/funcs');\n\nclass Seckill {\n  /**\n   * 秒杀接口\n   * \n   * @method post\n   * @param good_id 产品id\n   * @param accessToken 用户Token\n   * @param path 秒杀完成后跳转路径\n   */\n  async doSeckill(ctx, next) {\n    const body = ctx.request.body;\n    const accessToken = ctx.query.accessToken;\n    const path = body.path;\n\n    // 基本参数校验\n    if (!accessToken || !path) { return ctx.throwException(20001, '参数错误！'); };\n    // 判断此产品是否加入了抢购\n    const seckill = await seckillModel.findOne({\n      where: {\n        fk_good_id: ctx.params.good_id,\n      }\n    });\n    if (!seckill) { return ctx.throwException(30002, '该产品并未有抢购活动！'); };\n    // 判断是否有效\n    if (!seckill.is_valid) { return ctx.throwException(30003, '该活动已结束！'); };\n    // 判单是否开始、结束\n    if(moment().isBefore(moment(seckill.start_time))) {\n      return ctx.throwException(30004, '该抢购活动还未开始！');\n    }\n    if(moment().isAfter(moment(seckill.end_time))) {\n      return ctx.throwException(30005, '该抢购活动已经结束！');\n    }\n    // 判断是否卖完\n    if(seckill.amount < 1) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n    //获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的accessToken校验流程)\n    const userInfo = await UserModule.getUserInfo(accessToken);\n    if (!userInfo) { return ctx.throwException(10002, '用户不存在！'); };\n\n    // 判断登录用户是否已抢到（一个用户针对这次活动只能购买一次）\n    const orderInfo = await ordersModel.findOne({\n      where: {\n        user_id: userInfo.id,\n        seckill_id: seckill.id,\n      },\n    });\n    if (orderInfo) { return ctx.throwException(30007, '该用户已抢到该产品，无需再抢！'); };\n\n    // 扣库存\n    const count = await seckill.decrement('amount');\n    if (count.amount <= 0) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n    // 下单\n    const orderData = {\n      order_no: Date.now() + random_String(4), // 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 \n      good_id: ctx.params.good_id,\n      user_id: userInfo.id,\n      status: '1', // -1 已取消, 0 未付款， 1 已付款， 2已退款\n      order_type: '2', // 1 常规订单 2 秒杀订单\n      seckill_id: seckill.id, // 秒杀活动id\n      comment: '', // 备注\n    };\n    const order = ordersModel.create(orderData);\n\n    if (!order) { return ctx.throwException(30008, '抢购失败!'); };\n\n    ctx.send({\n      path,\n      data: '抢购成功!'\n    });\n\n  }\n\n}\n\nmodule.exports = new Seckill();\n```\n\n至此，秒杀接口用传统的关系型数据库就实现完成了，代码并不复杂，注释也很详细，不用特别的讲解大家也都能看懂，那它能不能正常工作呢，答案显然是否定的   \n通过`Jmeter`模拟以下测试：\n\n- 模拟5000并发下2000个用户进行秒杀，会发现`mysql`报出`timeout`错误，同时`seckill_goods`表`amount`字段变成负数，`orders`表中同样产生了多于200的记录（具体数据不同环境下会有差异），这就代表产生了超卖，跟秒杀规则不符\n- 模拟10000并发下单个用户进行秒杀，`orders`表中产生了多于1条的记录（具体数据不同环境下会有差异），这就说明一个用户针对这次活动买了多次，跟秒杀规则不符\n\n\n分析下代码会发现这其中的问题：\n\n- 步骤2，判断此产品是否加入了抢购   \n\n    直接在`mysql`中查询，因为是在秒杀场景下，并发会很高，大量的请求到数据库，显然mysql是扛不住的，毕竟`mysql`每秒只能支撑千级别的并发请求\n- 步骤7，判断登录用户是否已抢到   \n\n    在高并发下同一个用户上个订单还没有生成成功，再次判断是否抢到依然会判断为否，这种情况下代码并没有对扣减和下单操作做任何限制，因此就产生了单个用户购买多个产品的情况，跟一个用户针对这次活动只能购买一次的要求不符\n- 步骤8，扣库存操作   \n    \n    假设同时有1000个请求，这1000个请求在步骤5判断产品是否秒杀完的时候查询到的库存都是200，因此这些请求都会执行步骤8扣减库存，那库存肯定会变成负数，也就是产生了超卖现象\n\n\n\n### 解决方案\n经过分析得到三个问题需要解决：\n\n1. 秒杀数据需要支持高并发访问\n2. 一个用户针对这次活动只能购买一次的问题，也就是限购问题\n3. 减库存不能扣成负数，订单数不能超过设置的库存数，也就是超卖问题\n\n`Redis`作为内存型数据库，本身高速处理请求的特性可以支持高并发。针对超卖，也就是库存扣减变负数情况，`Redis`可以提供`Lua`脚本保证原子性和分布式锁两个解决高并发下数据不一致的问题。针对一个用户只能购买一次的要求，`Redis`的分布式锁可以解决问题。   \n因此，可以尝试用Redis解决上述问题，具体操作：\n\n- 为了支撑大量高并发的库存查验请求，需要用`Redis`保存秒杀活动数据（即`seckill_goods`表数据），这样一来请求可以直接从`Redis`中读取库存并进行查询，完成查询之后如果还有库存余量，就直接从`Redis`中扣除库存\n- 扣减库存操作在`Redis`中进行，但是因为`Redis`扣减这一操作是分为读和写两个步骤，也就是必须先读数据进行判断再执行减操作，因此如果对这两个操作没有做好控制，就导致数据被改错，依然会出现超卖现象，为了保证并发访问的正确性需要使用原子操作解决问题，`Redis`提供了使用`Lua`脚本包含多个操作来实现原子性的方案   \n以下是`Redis`官方文档对`Lua`脚本原子性的解释\n\n    >Atomicity of scripts\n    Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.\n    \n- 使用`Redis`实现分布式锁，对扣库存和写订单操作进行加锁，以保证一个用户只能购买一次的问题。\n    \n### 接入Redis\n首先，不再使用`seckill_goods`表，新增秒杀活动逻辑变为在`Redis`中插入数据，类型为`hash`类型，`key`规则为`seckill_good_ + 产品id`，现在假设新增一条`key`为`seckill_good_1`的记录，值为\n\n```js\n{\n    amount: 200,\n    start_time: '2020-06-20 00:00:00',\n    end_time: '2023-06-20 00:00:00',\n    is_valid: 1,\n    comment: '...',\n  }\n```\n其次，创建`lua`脚本保证扣减操作的原子性，脚本内容如下\n\n```lua\nif (redis.call('hexists', KEYS[1], KEYS[2]) == 1) then\n  local stock = tonumber(redis.call('hget', KEYS[1], KEYS[2]));\n  if (stock > 0) then\n    redis.call('hincrby',  KEYS[1], KEYS[2], -1);\n    return stock\n  end;\n  return 0\nend;\n```\n最后，完成代码，完整代码如下：\n\n```js\n// 引入相关库\nconst moment = require('moment');\nconst Op = require('sequelize').Op;\nconst { v4: uuidv4 } = require('uuid');\n// 引入数据库model文件\nconst seckillModel = require('../../dbs/mysql/models/seckill_goods');\nconst ordersModel = require('../../dbs/mysql/models/orders');\n// 引入Redis实例\nconst redis = require('../../dbs/redis');\n// 引入工具函数或工具类\nconst UserModule = require('../modules/user');\nconst { randomString, checkObjNull } = require('../../utils/tools/funcs');\n// 引入秒杀key前缀\nconst { SECKILL_GOOD, LOCK_KEY } = require('../../utils/constants/redis-prefixs');\n// 引入避免超卖lua脚本\nconst { stock, lock, unlock } = require('../../utils/scripts');\n\nclass Seckill {\n  async doSeckill(ctx, next) {\n    const body = ctx.request.body;\n    const goodId = ctx.params.good_id;\n    const accessToken = ctx.query.accessToken;\n    const path = body.path;\n\n    // 基本参数校验\n    if (!accessToken || !path) { return ctx.throwException(20001, '参数错误！'); };\n    // 判断此产品是否加入了抢购\n    const key = `${SECKILL_GOOD}${goodId}`;\n    const seckill = await redis.hgetall(key);\n    if (!checkObjNull(seckill)) { return ctx.throwException(30002, '该产品并未有抢购活动！'); };\n    // 判断是否有效\n    if (!seckill.is_valid) { return ctx.throwException(30003, '该活动已结束！'); };\n    // 判单是否开始、结束\n    if(moment().isBefore(moment(seckill.start_time))) {\n      return ctx.throwException(30004, '该抢购活动还未开始！');\n    }\n    if(moment().isAfter(moment(seckill.end_time))) {\n      return ctx.throwException(30005, '该抢购活动已经结束！');\n    }\n    // 判断是否卖完\n    if(seckill.amount < 1) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n    //获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的登录注册校验流程)\n    const userInfo = await UserModule.getUserInfo(accessToken);\n    if (!userInfo) { return ctx.throwException(10002, '用户不存在！'); };\n\n    // 判断登录用户是否已抢到\n    const orderInfo = await ordersModel.findOne({\n      where: {\n        user_id: userInfo.id,\n        good_id: goodId,\n        status: { [Op.between]: ['0', '1'] },\n      },\n    });\n    if (orderInfo) { return ctx.throwException(30007, '该用户已抢到该产品，无需再抢！'); };\n    \n    // 加锁，实现一个用户针对这次活动只能购买一次\n    const lockKey = `${LOCK_KEY}${userInfo.id}:${goodId}`; // 锁的key有用户id和商品id组成\n    const uuid = uuidv4();\n    const expireTime = moment(seckill.end_time).diff(moment(), 'minutes'); // 锁存在时间为当前时间和活动结束的时间差\n    const tryLock = await redis.eval(lock, 2, [lockKey, 'releaseTime', uuid, expireTime]);\n    \n    try {\n      if (tryLock === 1) {\n        // 扣库存\n        const count = await redis.eval(stock, 2, [key, 'amount', '', '']);\n        if (count <= 0) { return ctx.throwException(30006, '该产品已经卖完了！'); };\n\n        // 下单\n        const orderData = {\n          order_no: Date.now() + randomString(4), // 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 \n          good_id: goodId,\n          user_id: userInfo.id,\n          status: '1', // -1 已取消, 0 未付款， 1 已付款， 2已退款\n          order_type: '2', // 1 常规订单 2 秒杀订单\n          // seckill_id: seckill.id, // 秒杀活动id, redis中不维护秒杀活动id\n          comment: '', // 备注\n        };\n        const order = ordersModel.create(orderData);\n\n        if (!order) { return ctx.throwException(30008, '抢购失败!'); };\n      }\n    } catch (e) {\n      await redis.eval(unlock, 1, [lockKey, uuid]);\n      return ctx.throwException(30006, '该产品已经卖完了！');\n    }\n\n    ctx.send({\n      path,\n      data: '抢购成功!'\n    });\n  }\n\n}\n\nmodule.exports = new Seckill();\n```\n\n这里代码主要做个四个修改：\n\n1. 步骤2，判断产品是否加入了抢购，改为去`Redis`中查询\n2. 步骤7，判断登录用户是否已抢到，因为不在维护抢购活动`id`，所以改为使用用户`id`、产品`id`和状态`status`判断\n3. 步骤8，扣库存，改为使用`lua`脚本去`Redis`中扣库存\n4. 对扣库存和写入数据库操作进行加锁\n\n订单的操作仍然在`Mysql`数据库中进行，因为大部分的请求都在步骤5被拦截了，剩余请求`Mysql`是完全有能力处理的。   \n\n再次通过`Jmeter`进行测试，发现订单表正常，库存量扣减正常，说明超卖问题和限购已经解决。\n\n\n## 其他问题\n1. 秒杀场景的其他技术\n    基于`Redis`支持高并发、键值对型数据库和支持原子操作等特点，案例中使用`Redis`来作为秒杀应对方案。在更复杂的秒杀场景下，除了使用`Redis`外，在必要的的情况下还需要用到其他一些技术：\n    \n    - 限流，用漏斗算法、令牌桶算法等进行限流\n    - 缓存，把热点数据缓存到内存里，尽可能缓解数据库访问的压力\n    - 削峰，使用消息队列和缓存技术使瞬间高流量转变成一段时间的平稳流量，比如客户抢购成功后，立即返回响应，然后通过消息队列异步处理后续步骤，发短信，写日志，更新一致性低的数据库等等\n    - 异步，假设商家创建一个只针对粉丝的秒杀活动，如果商家的粉丝比较少（假设小于1000），那么秒杀活动直接推送给所有粉丝，如果用户粉丝比较多，程序立刻推送给排名前1000的用户，其余用户采用消息队列延迟推送。（1000这个数字需要根据具体情况决定，比如粉丝数2000以内的商家占99%，只有1%的用户粉丝超过2000，那么这个值就应该设置为2000）\n    - 分流，单台服务器不行就上集群，通过负载均衡共同去处理请求，分散压力\n  \n    这些技术的应用会让整个秒杀系统更加完善，但是核心技术还是`Redis`，可以说用好`Redis`实现的秒杀系统就足以应对大部分场景。\n    \n2. `Redis`健壮性\n    案例使用的是单机版`Redis`，单节点在生产环境基本上不会使用，因为\n    - 不能达到高可用\n    - 即便有着`AOF`日志和`RDB`快照的解决方案以保证数据不丢失，但都只能放在`master`上，一旦机器故障，服务就无法运行，而且即便采取了相应措施仍不可避免的会造成数据丢失。\n    \n    因此，`Redis`的主从机制和集群机制在生产环境下是必须的。\n3. `Redis`分布式锁的问题\n    - 单点分布式锁，案例提到的分布式锁，实际上更准确的说法是单点分布式锁，是为了方便演示，但是，单点`Redis`分布式锁是肯定不能用在生产环境的，理由跟第2点类似\n    - 以主从机制（多机器）为基础的分布式锁，也是不够的，因为`redis`在进行主从复制时是异步完成的，比如在`clientA`获取锁后，主`redis`复制数据到从`redis`过程中崩溃了，导致锁没有复制到从`redis`中，然后从`redis`选举出一个升级为主`redis`，造成新的主`redis`没有`clientA`设置的锁，这时`clientB`尝试获取锁，并且能够成功获取锁，导致互斥失效。\n    \n    针对以上问题，`redis`官方设计了`Redlock`，在`Node.js`环境下对应的资源库为`node-redlock`，可以用`npm`安装，至少需要3个独立的服务器或集群才能使用，提供了非常高的容错率，在生产环境中应该优先采用此方案部署。\n\n## 总结\n秒杀场景的特点可以总结为瞬时并发访问、读多写少、限时和限量，开发中还要考虑避免超卖现象以及类似黄牛抢票的限购问题，针对以上特点和问题，分析得到开发的原则是：数据写入内存而不是写入硬盘，异步处理而不是同步处理，扣库存操作原子执行以及对单用户购买进行加锁，而`Redis`正好是符合以上全部特点的工具，因此最终选择`Redis`来解决问题。\n\n秒杀场景是一个在电商业务中相对复杂的场景，此篇文章只是介绍了其中最核心的逻辑，实际业务可能更加复杂，但只需要在此核心基础上进行扩展和优化即可。   \n秒杀场景的解决方案不仅仅适合秒杀，类似的还有抢红包、抢优惠券以及抢票等等，思路都是一致的。   \n解决方案的思路还可以应用在单独限购、第二件半价以及控制库存等等诸多场景，大家要灵活运用。\n\n## 项目地址\n\n[https://github.com/threerocks/redis-seckill](https://github.com/threerocks/redis-seckill)\n## 参考资料\n[https://time.geekbang.org/column/article/307421](https://time.geekbang.org/column/article/307421)\n[https://redis.io/topics/distlock](https://redis.io/topics/distlock)\n\n\n\n\n","slug":"Redis应用实战 - 秒杀场景（Node.js版本）","published":1,"updated":"2021-06-25T10:10:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckqc71gum0002txzb7v1g07wd","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>公司随着业务量的增加，最近用时几个月时间在项目中全面接入<code>Redis</code>，开发过程中发现市面上缺少具体的实战资料，尤其是在<code>Node.js</code>环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍<code>Redis</code>的几个使用场景，期望大家一起学习、进步。<br>下面就开始第一篇，秒杀场景。</p>\n<h2 id=\"业务分析\"><a href=\"#业务分析\" class=\"headerlink\" title=\"业务分析\"></a>业务分析</h2><p>实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下：</p>\n<ol>\n<li>秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用<code>CDN</code>或者是浏览器进行缓存。</li>\n<li>秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是<ul>\n<li>短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高）</li>\n<li>请求数量大于商品库存，比如10000个用户抢购，但是库存只有100</li>\n<li>限定用户只能在一定时间段内购买</li>\n<li>限制单个用户购买数量，避免刷单</li>\n<li>抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数</li>\n<li>对数据库的操作读多写少，而且读操作相对简单</li>\n</ul>\n</li>\n<li>秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。</li>\n</ol>\n<p>根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>数据库：<code>Redis 3.2.9</code> + <code>Mysql 5.7.18</code><br>服务器：<code>Node.js v10.15.0</code><br>测试工具：<code>Jmeter-5.4.1</code></p>\n<span id=\"more\"></span>\n\n<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"数据库准备\"><a href=\"#数据库准备\" class=\"headerlink\" title=\"数据库准备\"></a>数据库准备</h3><p><img src=\"media/16239877134495/tables.jpg\" alt=\"tables\"><br>如图所示，<code>Mysql</code>中需要创建三张表，分别是</p>\n<ul>\n<li>产品表，用于记录产品信息，字段分别为Id、名称、缩略图、价格和状态等等</li>\n<li>秒杀活动表，用于记录秒杀活动的详细信息，字段分别为Id、参与秒杀的产品Id、库存量、秒杀开始时间、秒杀结束时间和秒杀活动是否有效等等</li>\n<li>订单表，用于记录下单后的数据，字段分别为Id、订单号、产品Id、购买用户Id、订单状态、订单类型和秒杀活动Id等等</li>\n</ul>\n<p>下面是创建<code>sql</code>语句，以供参考</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `scekill_goods` (</span><br><span class=\"line\">\t`id` <span class=\"type\">INTEGER</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> auto_increment,</span><br><span class=\"line\">\t`fk_good_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`amount` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`start_time` DATETIME,</span><br><span class=\"line\">\t`end_time` DATETIME,</span><br><span class=\"line\">\t`is_valid` TINYINT ( <span class=\"number\">1</span> ),</span><br><span class=\"line\">\t`comment` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`created_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">\t`updated_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY</span> KEY ( `id` ) </span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> INNODB <span class=\"keyword\">DEFAULT</span> CHARSET <span class=\"operator\">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `orders` (</span><br><span class=\"line\">\t`id` <span class=\"type\">INTEGER</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> auto_increment,</span><br><span class=\"line\">\t`order_no` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`good_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`user_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`status` ENUM ( <span class=\"string\">&#x27;-1&#x27;</span>, <span class=\"string\">&#x27;0&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span> ),</span><br><span class=\"line\">\t`order_type` ENUM ( <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span> ),</span><br><span class=\"line\">\t`scekill_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`comment` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`created_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">\t`updated_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY</span> KEY ( `id` ) </span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> INNODB <span class=\"keyword\">DEFAULT</span> CHARSET <span class=\"operator\">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `goods` (</span><br><span class=\"line\">\t`id` <span class=\"type\">INTEGER</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> auto_increment,</span><br><span class=\"line\">\t`name` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`thumbnail` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`price` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`status` TINYINT ( <span class=\"number\">1</span> ),</span><br><span class=\"line\">\t`stock` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`stock_left` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`description` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`comment` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`created_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">\t`updated_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY</span> KEY ( `id` ) </span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> INNODB <span class=\"keyword\">DEFAULT</span> CHARSET <span class=\"operator\">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>\n<p>产品表在此次业务中不是重点，以下逻辑都以<code>id=1</code>的产品为示例，请悉知。<br>秒杀活动表中创建一条库存为200的记录，作为秒杀测试数据，参考下面语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `redis_app`.`seckill_goods` (</span><br><span class=\"line\">\t`id`,</span><br><span class=\"line\">\t`fk_good_id`,</span><br><span class=\"line\">\t`amount`,</span><br><span class=\"line\">\t`start_time`,</span><br><span class=\"line\">\t`end_time`,</span><br><span class=\"line\">\t`is_valid`,</span><br><span class=\"line\">\t`comment`,</span><br><span class=\"line\">\t`created_at`,</span><br><span class=\"line\">\t`updated_at` </span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">\t(</span><br><span class=\"line\">\t\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">200</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2023-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2021-06-22 10:18:16&#x27;</span> </span><br><span class=\"line\">\t);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"秒杀接口开发\"><a href=\"#秒杀接口开发\" class=\"headerlink\" title=\"秒杀接口开发\"></a>秒杀接口开发</h3><p>首先，说一下<code>Node.js</code>中的具体开发环境:</p>\n<ul>\n<li><code>web</code>框架使用<code>Koa2</code></li>\n<li><code>mysql</code>操作使用基于<code>promise</code>的<code>Node.js</code> <code>ORM</code>工具<code>Sequelize</code></li>\n<li><code>redis</code>操作使用<code>ioredis</code>库</li>\n<li>封装<code>ctx.throwException</code>方法用于处理错误，封装<code>ctx.send</code>方法用于返回正确结果，具体实现参考文末完整代码</li>\n</ul>\n<p>其次，分析一下接口要处理的逻辑，大概步骤和顺序如下：</p>\n<ol>\n<li>基本参数校验</li>\n<li>判断产品是否加入了抢购</li>\n<li>判断秒杀活动是否有效</li>\n<li>判断秒杀活动是否开始、结束</li>\n<li>判断秒杀商品是否卖完</li>\n<li>获取登录用户信息</li>\n<li>判断登录用户是否已抢到</li>\n<li>扣库存</li>\n<li>下单</li>\n</ol>\n<p>最后，根据分析把以上步骤用代码进行初步实现，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入moment库处理时间相关数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;moment&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入数据库model文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> seckillModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/seckill_goods&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ordersModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/orders&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入工具函数或工具类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UserModule = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../modules/user&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; random_String &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/tools/funcs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Seckill</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 秒杀接口</span></span><br><span class=\"line\"><span class=\"comment\">   * </span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@method <span class=\"variable\">post</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param </span>good_id 产品id</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param </span>accessToken 用户Token</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param </span>path 秒杀完成后跳转路径</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">doSeckill</span>(<span class=\"params\">ctx, next</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> body = ctx.request.body;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accessToken = ctx.query.accessToken;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = body.path;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基本参数校验</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!accessToken || !path) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">20001</span>, <span class=\"string\">&#x27;参数错误！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断此产品是否加入了抢购</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> seckill = <span class=\"keyword\">await</span> seckillModel.findOne(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">fk_good_id</span>: ctx.params.good_id,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!seckill) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30002</span>, <span class=\"string\">&#x27;该产品并未有抢购活动！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!seckill.is_valid) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30003</span>, <span class=\"string\">&#x27;该活动已结束！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判单是否开始、结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isBefore(moment(seckill.start_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30004</span>, <span class=\"string\">&#x27;该抢购活动还未开始！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isAfter(moment(seckill.end_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30005</span>, <span class=\"string\">&#x27;该抢购活动已经结束！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否卖完</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(seckill.amount &lt; <span class=\"number\">1</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的accessToken校验流程)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> userInfo = <span class=\"keyword\">await</span> UserModule.getUserInfo(accessToken);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!userInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">10002</span>, <span class=\"string\">&#x27;用户不存在！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断登录用户是否已抢到（一个用户针对这次活动只能购买一次）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> orderInfo = <span class=\"keyword\">await</span> ordersModel.findOne(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">        <span class=\"attr\">seckill_id</span>: seckill.id,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (orderInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30007</span>, <span class=\"string\">&#x27;该用户已抢到该产品，无需再抢！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扣库存</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = <span class=\"keyword\">await</span> seckill.decrement(<span class=\"string\">&#x27;amount&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count.amount &lt;= <span class=\"number\">0</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下单</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> orderData = &#123;</span><br><span class=\"line\">      <span class=\"attr\">order_no</span>: <span class=\"built_in\">Date</span>.now() + random_String(<span class=\"number\">4</span>), <span class=\"comment\">// 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 </span></span><br><span class=\"line\">      <span class=\"attr\">good_id</span>: ctx.params.good_id,</span><br><span class=\"line\">      <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">      <span class=\"attr\">status</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"comment\">// -1 已取消, 0 未付款， 1 已付款， 2已退款</span></span><br><span class=\"line\">      <span class=\"attr\">order_type</span>: <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"comment\">// 1 常规订单 2 秒杀订单</span></span><br><span class=\"line\">      <span class=\"attr\">seckill_id</span>: seckill.id, <span class=\"comment\">// 秒杀活动id</span></span><br><span class=\"line\">      <span class=\"attr\">comment</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"comment\">// 备注</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> order = ordersModel.create(orderData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!order) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30008</span>, <span class=\"string\">&#x27;抢购失败!&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.send(&#123;</span><br><span class=\"line\">      path,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: <span class=\"string\">&#x27;抢购成功!&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">new</span> Seckill();</span><br></pre></td></tr></table></figure>\n\n<p>至此，秒杀接口用传统的关系型数据库就实现完成了，代码并不复杂，注释也很详细，不用特别的讲解大家也都能看懂，那它能不能正常工作呢，答案显然是否定的<br>通过<code>Jmeter</code>模拟以下测试：</p>\n<ul>\n<li>模拟5000并发下2000个用户进行秒杀，会发现<code>mysql</code>报出<code>timeout</code>错误，同时<code>seckill_goods</code>表<code>amount</code>字段变成负数，<code>orders</code>表中同样产生了多于200的记录（具体数据不同环境下会有差异），这就代表产生了超卖，跟秒杀规则不符</li>\n<li>模拟10000并发下单个用户进行秒杀，<code>orders</code>表中产生了多于1条的记录（具体数据不同环境下会有差异），这就说明一个用户针对这次活动买了多次，跟秒杀规则不符</li>\n</ul>\n<p>分析下代码会发现这其中的问题：</p>\n<ul>\n<li><p>步骤2，判断此产品是否加入了抢购   </p>\n<p>  直接在<code>mysql</code>中查询，因为是在秒杀场景下，并发会很高，大量的请求到数据库，显然mysql是扛不住的，毕竟<code>mysql</code>每秒只能支撑千级别的并发请求</p>\n</li>\n<li><p>步骤7，判断登录用户是否已抢到   </p>\n<p>  在高并发下同一个用户上个订单还没有生成成功，再次判断是否抢到依然会判断为否，这种情况下代码并没有对扣减和下单操作做任何限制，因此就产生了单个用户购买多个产品的情况，跟一个用户针对这次活动只能购买一次的要求不符</p>\n</li>\n<li><p>步骤8，扣库存操作   </p>\n<p>  假设同时有1000个请求，这1000个请求在步骤5判断产品是否秒杀完的时候查询到的库存都是200，因此这些请求都会执行步骤8扣减库存，那库存肯定会变成负数，也就是产生了超卖现象</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>经过分析得到三个问题需要解决：</p>\n<ol>\n<li>秒杀数据需要支持高并发访问</li>\n<li>一个用户针对这次活动只能购买一次的问题，也就是限购问题</li>\n<li>减库存不能扣成负数，订单数不能超过设置的库存数，也就是超卖问题</li>\n</ol>\n<p><code>Redis</code>作为内存型数据库，本身高速处理请求的特性可以支持高并发。针对超卖，也就是库存扣减变负数情况，<code>Redis</code>可以提供<code>Lua</code>脚本保证原子性和分布式锁两个解决高并发下数据不一致的问题。针对一个用户只能购买一次的要求，<code>Redis</code>的分布式锁可以解决问题。<br>因此，可以尝试用Redis解决上述问题，具体操作：</p>\n<ul>\n<li><p>为了支撑大量高并发的库存查验请求，需要用<code>Redis</code>保存秒杀活动数据（即<code>seckill_goods</code>表数据），这样一来请求可以直接从<code>Redis</code>中读取库存并进行查询，完成查询之后如果还有库存余量，就直接从<code>Redis</code>中扣除库存</p>\n</li>\n<li><p>扣减库存操作在<code>Redis</code>中进行，但是因为<code>Redis</code>扣减这一操作是分为读和写两个步骤，也就是必须先读数据进行判断再执行减操作，因此如果对这两个操作没有做好控制，就导致数据被改错，依然会出现超卖现象，为了保证并发访问的正确性需要使用原子操作解决问题，<code>Redis</code>提供了使用<code>Lua</code>脚本包含多个操作来实现原子性的方案<br>以下是<code>Redis</code>官方文档对<code>Lua</code>脚本原子性的解释</p>\n<blockquote>\n<p>Atomicity of scripts<br>  Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</p>\n</blockquote>\n</li>\n<li><p>使用<code>Redis</code>实现分布式锁，对扣库存和写订单操作进行加锁，以保证一个用户只能购买一次的问题。</p>\n</li>\n</ul>\n<h3 id=\"接入Redis\"><a href=\"#接入Redis\" class=\"headerlink\" title=\"接入Redis\"></a>接入Redis</h3><p>首先，不再使用<code>seckill_goods</code>表，新增秒杀活动逻辑变为在<code>Redis</code>中插入数据，类型为<code>hash</code>类型，<code>key</code>规则为<code>seckill_good_ + 产品id</code>，现在假设新增一条<code>key</code>为<code>seckill_good_1</code>的记录，值为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">amount</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    <span class=\"attr\">start_time</span>: <span class=\"string\">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">end_time</span>: <span class=\"string\">&#x27;2023-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">is_valid</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">comment</span>: <span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其次，创建<code>lua</code>脚本保证扣减操作的原子性，脚本内容如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], KEYS[<span class=\"number\">2</span>]) == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;hget&#x27;</span>, KEYS[<span class=\"number\">1</span>], KEYS[<span class=\"number\">2</span>]));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>,  KEYS[<span class=\"number\">1</span>], KEYS[<span class=\"number\">2</span>], <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stock</span><br><span class=\"line\">  <span class=\"keyword\">end</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure>\n<p>最后，完成代码，完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入相关库</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;moment&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Op = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;sequelize&#x27;</span>).Op;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">v4</span>: uuidv4 &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;uuid&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入数据库model文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> seckillModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/seckill_goods&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ordersModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/orders&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入Redis实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/redis&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入工具函数或工具类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UserModule = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../modules/user&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; randomString, checkObjNull &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/tools/funcs&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入秒杀key前缀</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; SECKILL_GOOD, LOCK_KEY &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/constants/redis-prefixs&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入避免超卖lua脚本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; stock, lock, unlock &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/scripts&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Seckill</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">doSeckill</span>(<span class=\"params\">ctx, next</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> body = ctx.request.body;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> goodId = ctx.params.good_id;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accessToken = ctx.query.accessToken;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = body.path;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基本参数校验</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!accessToken || !path) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">20001</span>, <span class=\"string\">&#x27;参数错误！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断此产品是否加入了抢购</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"string\">`<span class=\"subst\">$&#123;SECKILL_GOOD&#125;</span><span class=\"subst\">$&#123;goodId&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> seckill = <span class=\"keyword\">await</span> redis.hgetall(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!checkObjNull(seckill)) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30002</span>, <span class=\"string\">&#x27;该产品并未有抢购活动！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!seckill.is_valid) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30003</span>, <span class=\"string\">&#x27;该活动已结束！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判单是否开始、结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isBefore(moment(seckill.start_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30004</span>, <span class=\"string\">&#x27;该抢购活动还未开始！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isAfter(moment(seckill.end_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30005</span>, <span class=\"string\">&#x27;该抢购活动已经结束！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否卖完</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(seckill.amount &lt; <span class=\"number\">1</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的登录注册校验流程)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> userInfo = <span class=\"keyword\">await</span> UserModule.getUserInfo(accessToken);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!userInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">10002</span>, <span class=\"string\">&#x27;用户不存在！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断登录用户是否已抢到</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> orderInfo = <span class=\"keyword\">await</span> ordersModel.findOne(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">        <span class=\"attr\">good_id</span>: goodId,</span><br><span class=\"line\">        <span class=\"attr\">status</span>: &#123; [Op.between]: [<span class=\"string\">&#x27;0&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>] &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (orderInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30007</span>, <span class=\"string\">&#x27;该用户已抢到该产品，无需再抢！&#x27;</span>); &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加锁，实现一个用户针对这次活动只能购买一次</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> lockKey = <span class=\"string\">`<span class=\"subst\">$&#123;LOCK_KEY&#125;</span><span class=\"subst\">$&#123;userInfo.id&#125;</span>:<span class=\"subst\">$&#123;goodId&#125;</span>`</span>; <span class=\"comment\">// 锁的key有用户id和商品id组成</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uuid = uuidv4();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> expireTime = moment(seckill.end_time).diff(moment(), <span class=\"string\">&#x27;minutes&#x27;</span>); <span class=\"comment\">// 锁存在时间为当前时间和活动结束的时间差</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> tryLock = <span class=\"keyword\">await</span> redis.eval(lock, <span class=\"number\">2</span>, [lockKey, <span class=\"string\">&#x27;releaseTime&#x27;</span>, uuid, expireTime]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (tryLock === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 扣库存</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> count = <span class=\"keyword\">await</span> redis.eval(stock, <span class=\"number\">2</span>, [key, <span class=\"string\">&#x27;amount&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下单</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> orderData = &#123;</span><br><span class=\"line\">          <span class=\"attr\">order_no</span>: <span class=\"built_in\">Date</span>.now() + randomString(<span class=\"number\">4</span>), <span class=\"comment\">// 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 </span></span><br><span class=\"line\">          <span class=\"attr\">good_id</span>: goodId,</span><br><span class=\"line\">          <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">          <span class=\"attr\">status</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"comment\">// -1 已取消, 0 未付款， 1 已付款， 2已退款</span></span><br><span class=\"line\">          <span class=\"attr\">order_type</span>: <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"comment\">// 1 常规订单 2 秒杀订单</span></span><br><span class=\"line\">          <span class=\"comment\">// seckill_id: seckill.id, // 秒杀活动id, redis中不维护秒杀活动id</span></span><br><span class=\"line\">          <span class=\"attr\">comment</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"comment\">// 备注</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> order = ordersModel.create(orderData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!order) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30008</span>, <span class=\"string\">&#x27;抢购失败!&#x27;</span>); &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> redis.eval(unlock, <span class=\"number\">1</span>, [lockKey, uuid]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.send(&#123;</span><br><span class=\"line\">      path,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: <span class=\"string\">&#x27;抢购成功!&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">new</span> Seckill();</span><br></pre></td></tr></table></figure>\n\n<p>这里代码主要做个四个修改：</p>\n<ol>\n<li>步骤2，判断产品是否加入了抢购，改为去<code>Redis</code>中查询</li>\n<li>步骤7，判断登录用户是否已抢到，因为不在维护抢购活动<code>id</code>，所以改为使用用户<code>id</code>、产品<code>id</code>和状态<code>status</code>判断</li>\n<li>步骤8，扣库存，改为使用<code>lua</code>脚本去<code>Redis</code>中扣库存</li>\n<li>对扣库存和写入数据库操作进行加锁</li>\n</ol>\n<p>订单的操作仍然在<code>Mysql</code>数据库中进行，因为大部分的请求都在步骤5被拦截了，剩余请求<code>Mysql</code>是完全有能力处理的。   </p>\n<p>再次通过<code>Jmeter</code>进行测试，发现订单表正常，库存量扣减正常，说明超卖问题和限购已经解决。</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><ol>\n<li>秒杀场景的其他技术<br> 基于<code>Redis</code>支持高并发、键值对型数据库和支持原子操作等特点，案例中使用<code>Redis</code>来作为秒杀应对方案。在更复杂的秒杀场景下，除了使用<code>Redis</code>外，在必要的的情况下还需要用到其他一些技术：<ul>\n<li>限流，用漏斗算法、令牌桶算法等进行限流</li>\n<li>缓存，把热点数据缓存到内存里，尽可能缓解数据库访问的压力</li>\n<li>削峰，使用消息队列和缓存技术使瞬间高流量转变成一段时间的平稳流量，比如客户抢购成功后，立即返回响应，然后通过消息队列异步处理后续步骤，发短信，写日志，更新一致性低的数据库等等</li>\n<li>异步，假设商家创建一个只针对粉丝的秒杀活动，如果商家的粉丝比较少（假设小于1000），那么秒杀活动直接推送给所有粉丝，如果用户粉丝比较多，程序立刻推送给排名前1000的用户，其余用户采用消息队列延迟推送。（1000这个数字需要根据具体情况决定，比如粉丝数2000以内的商家占99%，只有1%的用户粉丝超过2000，那么这个值就应该设置为2000）</li>\n<li>分流，单台服务器不行就上集群，通过负载均衡共同去处理请求，分散压力</li>\n</ul>\n 这些技术的应用会让整个秒杀系统更加完善，但是核心技术还是<code>Redis</code>，可以说用好<code>Redis</code>实现的秒杀系统就足以应对大部分场景。</li>\n<li><code>Redis</code>健壮性<br> 案例使用的是单机版<code>Redis</code>，单节点在生产环境基本上不会使用，因为<ul>\n<li>不能达到高可用</li>\n<li>即便有着<code>AOF</code>日志和<code>RDB</code>快照的解决方案以保证数据不丢失，但都只能放在<code>master</code>上，一旦机器故障，服务就无法运行，而且即便采取了相应措施仍不可避免的会造成数据丢失。</li>\n</ul>\n 因此，<code>Redis</code>的主从机制和集群机制在生产环境下是必须的。</li>\n<li><code>Redis</code>分布式锁的问题<ul>\n<li>单点分布式锁，案例提到的分布式锁，实际上更准确的说法是单点分布式锁，是为了方便演示，但是，单点<code>Redis</code>分布式锁是肯定不能用在生产环境的，理由跟第2点类似</li>\n<li>以主从机制（多机器）为基础的分布式锁，也是不够的，因为<code>redis</code>在进行主从复制时是异步完成的，比如在<code>clientA</code>获取锁后，主<code>redis</code>复制数据到从<code>redis</code>过程中崩溃了，导致锁没有复制到从<code>redis</code>中，然后从<code>redis</code>选举出一个升级为主<code>redis</code>，造成新的主<code>redis</code>没有<code>clientA</code>设置的锁，这时<code>clientB</code>尝试获取锁，并且能够成功获取锁，导致互斥失效。</li>\n</ul>\n 针对以上问题，<code>redis</code>官方设计了<code>Redlock</code>，在<code>Node.js</code>环境下对应的资源库为<code>node-redlock</code>，可以用<code>npm</code>安装，至少需要3个独立的服务器或集群才能使用，提供了非常高的容错率，在生产环境中应该优先采用此方案部署。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>秒杀场景的特点可以总结为瞬时并发访问、读多写少、限时和限量，开发中还要考虑避免超卖现象以及类似黄牛抢票的限购问题，针对以上特点和问题，分析得到开发的原则是：数据写入内存而不是写入硬盘，异步处理而不是同步处理，扣库存操作原子执行以及对单用户购买进行加锁，而<code>Redis</code>正好是符合以上全部特点的工具，因此最终选择<code>Redis</code>来解决问题。</p>\n<p>秒杀场景是一个在电商业务中相对复杂的场景，此篇文章只是介绍了其中最核心的逻辑，实际业务可能更加复杂，但只需要在此核心基础上进行扩展和优化即可。<br>秒杀场景的解决方案不仅仅适合秒杀，类似的还有抢红包、抢优惠券以及抢票等等，思路都是一致的。<br>解决方案的思路还可以应用在单独限购、第二件半价以及控制库存等等诸多场景，大家要灵活运用。</p>\n<h2 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h2><p><a href=\"https://github.com/threerocks/redis-seckill\">https://github.com/threerocks/redis-seckill</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://time.geekbang.org/column/article/307421\">https://time.geekbang.org/column/article/307421</a><br><a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p>公司随着业务量的增加，最近用时几个月时间在项目中全面接入<code>Redis</code>，开发过程中发现市面上缺少具体的实战资料，尤其是在<code>Node.js</code>环境下，能找到的资料要么过于简单入门，要么名不副实，大部分都是属于初级。因此决定把公司这段时间的成果进行分享，会用几篇文章详细介绍<code>Redis</code>的几个使用场景，期望大家一起学习、进步。<br>下面就开始第一篇，秒杀场景。</p>\n<h2 id=\"业务分析\"><a href=\"#业务分析\" class=\"headerlink\" title=\"业务分析\"></a>业务分析</h2><p>实际业务中，秒杀包含了许多场景，具体可以分为秒杀前、秒杀中和秒杀后三个阶段，从开发角度具体分析如下：</p>\n<ol>\n<li>秒杀前：主要是做好缓存工作，以应对用户频繁的访问，因为数据是固定的，可以把商品详情页的元素静态化，然后用<code>CDN</code>或者是浏览器进行缓存。</li>\n<li>秒杀中：主要是库存查验，库存扣减和订单处理，这一步的特点是<ul>\n<li>短时间内大量用户同时进行抢购，系统的流量突然激增，服务器压力瞬间增大（瞬时并发访问高）</li>\n<li>请求数量大于商品库存，比如10000个用户抢购，但是库存只有100</li>\n<li>限定用户只能在一定时间段内购买</li>\n<li>限制单个用户购买数量，避免刷单</li>\n<li>抢购是跟数据库打交道，核心功能是下单，库存不能扣成负数</li>\n<li>对数据库的操作读多写少，而且读操作相对简单</li>\n</ul>\n</li>\n<li>秒杀后：主要是一些用户查看已购订单、处理退款和处理物流等等操作，这时候用户请求量已经下降，操作也相对简单，服务器压力不大。</li>\n</ol>\n<p>根据上述分析，本文把重点放在秒杀中的开发讲解，其他部分感兴趣的小伙伴可以自己搜索资料，进行尝试。</p>\n<h2 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h2><p>数据库：<code>Redis 3.2.9</code> + <code>Mysql 5.7.18</code><br>服务器：<code>Node.js v10.15.0</code><br>测试工具：<code>Jmeter-5.4.1</code></p>","more":"<h2 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h2><h3 id=\"数据库准备\"><a href=\"#数据库准备\" class=\"headerlink\" title=\"数据库准备\"></a>数据库准备</h3><p><img src=\"media/16239877134495/tables.jpg\" alt=\"tables\"><br>如图所示，<code>Mysql</code>中需要创建三张表，分别是</p>\n<ul>\n<li>产品表，用于记录产品信息，字段分别为Id、名称、缩略图、价格和状态等等</li>\n<li>秒杀活动表，用于记录秒杀活动的详细信息，字段分别为Id、参与秒杀的产品Id、库存量、秒杀开始时间、秒杀结束时间和秒杀活动是否有效等等</li>\n<li>订单表，用于记录下单后的数据，字段分别为Id、订单号、产品Id、购买用户Id、订单状态、订单类型和秒杀活动Id等等</li>\n</ul>\n<p>下面是创建<code>sql</code>语句，以供参考</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `scekill_goods` (</span><br><span class=\"line\">\t`id` <span class=\"type\">INTEGER</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> auto_increment,</span><br><span class=\"line\">\t`fk_good_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`amount` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`start_time` DATETIME,</span><br><span class=\"line\">\t`end_time` DATETIME,</span><br><span class=\"line\">\t`is_valid` TINYINT ( <span class=\"number\">1</span> ),</span><br><span class=\"line\">\t`comment` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`created_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">\t`updated_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY</span> KEY ( `id` ) </span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> INNODB <span class=\"keyword\">DEFAULT</span> CHARSET <span class=\"operator\">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `orders` (</span><br><span class=\"line\">\t`id` <span class=\"type\">INTEGER</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> auto_increment,</span><br><span class=\"line\">\t`order_no` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`good_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`user_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`status` ENUM ( <span class=\"string\">&#x27;-1&#x27;</span>, <span class=\"string\">&#x27;0&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span> ),</span><br><span class=\"line\">\t`order_type` ENUM ( <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"string\">&#x27;2&#x27;</span> ),</span><br><span class=\"line\">\t`scekill_id` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`comment` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`created_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">\t`updated_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY</span> KEY ( `id` ) </span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> INNODB <span class=\"keyword\">DEFAULT</span> CHARSET <span class=\"operator\">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>\n\n\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> `goods` (</span><br><span class=\"line\">\t`id` <span class=\"type\">INTEGER</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span> auto_increment,</span><br><span class=\"line\">\t`name` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`thumbnail` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`price` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`status` TINYINT ( <span class=\"number\">1</span> ),</span><br><span class=\"line\">\t`stock` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`stock_left` <span class=\"type\">INTEGER</span>,</span><br><span class=\"line\">\t`description` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`comment` <span class=\"type\">VARCHAR</span> ( <span class=\"number\">255</span> ),</span><br><span class=\"line\">\t`created_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\">\t`updated_at` DATETIME <span class=\"keyword\">NOT</span> <span class=\"keyword\">NULL</span>,</span><br><span class=\"line\"><span class=\"keyword\">PRIMARY</span> KEY ( `id` ) </span><br><span class=\"line\">) ENGINE <span class=\"operator\">=</span> INNODB <span class=\"keyword\">DEFAULT</span> CHARSET <span class=\"operator\">=</span> utf8mb4;</span><br></pre></td></tr></table></figure>\n<p>产品表在此次业务中不是重点，以下逻辑都以<code>id=1</code>的产品为示例，请悉知。<br>秒杀活动表中创建一条库存为200的记录，作为秒杀测试数据，参考下面语句：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> `redis_app`.`seckill_goods` (</span><br><span class=\"line\">\t`id`,</span><br><span class=\"line\">\t`fk_good_id`,</span><br><span class=\"line\">\t`amount`,</span><br><span class=\"line\">\t`start_time`,</span><br><span class=\"line\">\t`end_time`,</span><br><span class=\"line\">\t`is_valid`,</span><br><span class=\"line\">\t`comment`,</span><br><span class=\"line\">\t`created_at`,</span><br><span class=\"line\">\t`updated_at` </span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"keyword\">VALUES</span></span><br><span class=\"line\">\t(</span><br><span class=\"line\">\t\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">200</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2023-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">1</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"string\">&#x27;2021-06-22 10:18:16&#x27;</span> </span><br><span class=\"line\">\t);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"秒杀接口开发\"><a href=\"#秒杀接口开发\" class=\"headerlink\" title=\"秒杀接口开发\"></a>秒杀接口开发</h3><p>首先，说一下<code>Node.js</code>中的具体开发环境:</p>\n<ul>\n<li><code>web</code>框架使用<code>Koa2</code></li>\n<li><code>mysql</code>操作使用基于<code>promise</code>的<code>Node.js</code> <code>ORM</code>工具<code>Sequelize</code></li>\n<li><code>redis</code>操作使用<code>ioredis</code>库</li>\n<li>封装<code>ctx.throwException</code>方法用于处理错误，封装<code>ctx.send</code>方法用于返回正确结果，具体实现参考文末完整代码</li>\n</ul>\n<p>其次，分析一下接口要处理的逻辑，大概步骤和顺序如下：</p>\n<ol>\n<li>基本参数校验</li>\n<li>判断产品是否加入了抢购</li>\n<li>判断秒杀活动是否有效</li>\n<li>判断秒杀活动是否开始、结束</li>\n<li>判断秒杀商品是否卖完</li>\n<li>获取登录用户信息</li>\n<li>判断登录用户是否已抢到</li>\n<li>扣库存</li>\n<li>下单</li>\n</ol>\n<p>最后，根据分析把以上步骤用代码进行初步实现，如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入moment库处理时间相关数据</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;moment&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入数据库model文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> seckillModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/seckill_goods&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ordersModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/orders&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入工具函数或工具类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UserModule = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../modules/user&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; random_String &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/tools/funcs&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Seckill</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">   * 秒杀接口</span></span><br><span class=\"line\"><span class=\"comment\">   * </span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@method <span class=\"variable\">post</span></span></span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param </span>good_id 产品id</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param </span>accessToken 用户Token</span></span><br><span class=\"line\"><span class=\"comment\">   * <span class=\"doctag\">@param </span>path 秒杀完成后跳转路径</span></span><br><span class=\"line\"><span class=\"comment\">   */</span></span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">doSeckill</span>(<span class=\"params\">ctx, next</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> body = ctx.request.body;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accessToken = ctx.query.accessToken;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = body.path;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基本参数校验</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!accessToken || !path) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">20001</span>, <span class=\"string\">&#x27;参数错误！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断此产品是否加入了抢购</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> seckill = <span class=\"keyword\">await</span> seckillModel.findOne(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">fk_good_id</span>: ctx.params.good_id,</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!seckill) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30002</span>, <span class=\"string\">&#x27;该产品并未有抢购活动！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!seckill.is_valid) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30003</span>, <span class=\"string\">&#x27;该活动已结束！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判单是否开始、结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isBefore(moment(seckill.start_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30004</span>, <span class=\"string\">&#x27;该抢购活动还未开始！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isAfter(moment(seckill.end_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30005</span>, <span class=\"string\">&#x27;该抢购活动已经结束！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否卖完</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(seckill.amount &lt; <span class=\"number\">1</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的accessToken校验流程)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> userInfo = <span class=\"keyword\">await</span> UserModule.getUserInfo(accessToken);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!userInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">10002</span>, <span class=\"string\">&#x27;用户不存在！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断登录用户是否已抢到（一个用户针对这次活动只能购买一次）</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> orderInfo = <span class=\"keyword\">await</span> ordersModel.findOne(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">        <span class=\"attr\">seckill_id</span>: seckill.id,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (orderInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30007</span>, <span class=\"string\">&#x27;该用户已抢到该产品，无需再抢！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 扣库存</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> count = <span class=\"keyword\">await</span> seckill.decrement(<span class=\"string\">&#x27;amount&#x27;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count.amount &lt;= <span class=\"number\">0</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 下单</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> orderData = &#123;</span><br><span class=\"line\">      <span class=\"attr\">order_no</span>: <span class=\"built_in\">Date</span>.now() + random_String(<span class=\"number\">4</span>), <span class=\"comment\">// 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 </span></span><br><span class=\"line\">      <span class=\"attr\">good_id</span>: ctx.params.good_id,</span><br><span class=\"line\">      <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">      <span class=\"attr\">status</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"comment\">// -1 已取消, 0 未付款， 1 已付款， 2已退款</span></span><br><span class=\"line\">      <span class=\"attr\">order_type</span>: <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"comment\">// 1 常规订单 2 秒杀订单</span></span><br><span class=\"line\">      <span class=\"attr\">seckill_id</span>: seckill.id, <span class=\"comment\">// 秒杀活动id</span></span><br><span class=\"line\">      <span class=\"attr\">comment</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"comment\">// 备注</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> order = ordersModel.create(orderData);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!order) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30008</span>, <span class=\"string\">&#x27;抢购失败!&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.send(&#123;</span><br><span class=\"line\">      path,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: <span class=\"string\">&#x27;抢购成功!&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">new</span> Seckill();</span><br></pre></td></tr></table></figure>\n\n<p>至此，秒杀接口用传统的关系型数据库就实现完成了，代码并不复杂，注释也很详细，不用特别的讲解大家也都能看懂，那它能不能正常工作呢，答案显然是否定的<br>通过<code>Jmeter</code>模拟以下测试：</p>\n<ul>\n<li>模拟5000并发下2000个用户进行秒杀，会发现<code>mysql</code>报出<code>timeout</code>错误，同时<code>seckill_goods</code>表<code>amount</code>字段变成负数，<code>orders</code>表中同样产生了多于200的记录（具体数据不同环境下会有差异），这就代表产生了超卖，跟秒杀规则不符</li>\n<li>模拟10000并发下单个用户进行秒杀，<code>orders</code>表中产生了多于1条的记录（具体数据不同环境下会有差异），这就说明一个用户针对这次活动买了多次，跟秒杀规则不符</li>\n</ul>\n<p>分析下代码会发现这其中的问题：</p>\n<ul>\n<li><p>步骤2，判断此产品是否加入了抢购   </p>\n<p>  直接在<code>mysql</code>中查询，因为是在秒杀场景下，并发会很高，大量的请求到数据库，显然mysql是扛不住的，毕竟<code>mysql</code>每秒只能支撑千级别的并发请求</p>\n</li>\n<li><p>步骤7，判断登录用户是否已抢到   </p>\n<p>  在高并发下同一个用户上个订单还没有生成成功，再次判断是否抢到依然会判断为否，这种情况下代码并没有对扣减和下单操作做任何限制，因此就产生了单个用户购买多个产品的情况，跟一个用户针对这次活动只能购买一次的要求不符</p>\n</li>\n<li><p>步骤8，扣库存操作   </p>\n<p>  假设同时有1000个请求，这1000个请求在步骤5判断产品是否秒杀完的时候查询到的库存都是200，因此这些请求都会执行步骤8扣减库存，那库存肯定会变成负数，也就是产生了超卖现象</p>\n</li>\n</ul>\n<h3 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h3><p>经过分析得到三个问题需要解决：</p>\n<ol>\n<li>秒杀数据需要支持高并发访问</li>\n<li>一个用户针对这次活动只能购买一次的问题，也就是限购问题</li>\n<li>减库存不能扣成负数，订单数不能超过设置的库存数，也就是超卖问题</li>\n</ol>\n<p><code>Redis</code>作为内存型数据库，本身高速处理请求的特性可以支持高并发。针对超卖，也就是库存扣减变负数情况，<code>Redis</code>可以提供<code>Lua</code>脚本保证原子性和分布式锁两个解决高并发下数据不一致的问题。针对一个用户只能购买一次的要求，<code>Redis</code>的分布式锁可以解决问题。<br>因此，可以尝试用Redis解决上述问题，具体操作：</p>\n<ul>\n<li><p>为了支撑大量高并发的库存查验请求，需要用<code>Redis</code>保存秒杀活动数据（即<code>seckill_goods</code>表数据），这样一来请求可以直接从<code>Redis</code>中读取库存并进行查询，完成查询之后如果还有库存余量，就直接从<code>Redis</code>中扣除库存</p>\n</li>\n<li><p>扣减库存操作在<code>Redis</code>中进行，但是因为<code>Redis</code>扣减这一操作是分为读和写两个步骤，也就是必须先读数据进行判断再执行减操作，因此如果对这两个操作没有做好控制，就导致数据被改错，依然会出现超卖现象，为了保证并发访问的正确性需要使用原子操作解决问题，<code>Redis</code>提供了使用<code>Lua</code>脚本包含多个操作来实现原子性的方案<br>以下是<code>Redis</code>官方文档对<code>Lua</code>脚本原子性的解释</p>\n<blockquote>\n<p>Atomicity of scripts<br>  Redis uses the same Lua interpreter to run all the commands. Also Redis guarantees that a script is executed in an atomic way: no other script or Redis command will be executed while a script is being executed. This semantic is similar to the one of MULTI / EXEC. From the point of view of all the other clients the effects of a script are either still not visible or already completed.</p>\n</blockquote>\n</li>\n<li><p>使用<code>Redis</code>实现分布式锁，对扣库存和写订单操作进行加锁，以保证一个用户只能购买一次的问题。</p>\n</li>\n</ul>\n<h3 id=\"接入Redis\"><a href=\"#接入Redis\" class=\"headerlink\" title=\"接入Redis\"></a>接入Redis</h3><p>首先，不再使用<code>seckill_goods</code>表，新增秒杀活动逻辑变为在<code>Redis</code>中插入数据，类型为<code>hash</code>类型，<code>key</code>规则为<code>seckill_good_ + 产品id</code>，现在假设新增一条<code>key</code>为<code>seckill_good_1</code>的记录，值为</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"attr\">amount</span>: <span class=\"number\">200</span>,</span><br><span class=\"line\">    <span class=\"attr\">start_time</span>: <span class=\"string\">&#x27;2020-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">end_time</span>: <span class=\"string\">&#x27;2023-06-20 00:00:00&#x27;</span>,</span><br><span class=\"line\">    <span class=\"attr\">is_valid</span>: <span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"attr\">comment</span>: <span class=\"string\">&#x27;...&#x27;</span>,</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>其次，创建<code>lua</code>脚本保证扣减操作的原子性，脚本内容如下</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (redis.call(<span class=\"string\">&#x27;hexists&#x27;</span>, KEYS[<span class=\"number\">1</span>], KEYS[<span class=\"number\">2</span>]) == <span class=\"number\">1</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">  <span class=\"keyword\">local</span> stock = <span class=\"built_in\">tonumber</span>(redis.call(<span class=\"string\">&#x27;hget&#x27;</span>, KEYS[<span class=\"number\">1</span>], KEYS[<span class=\"number\">2</span>]));</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stock &gt; <span class=\"number\">0</span>) <span class=\"keyword\">then</span></span><br><span class=\"line\">    redis.call(<span class=\"string\">&#x27;hincrby&#x27;</span>,  KEYS[<span class=\"number\">1</span>], KEYS[<span class=\"number\">2</span>], <span class=\"number\">-1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> stock</span><br><span class=\"line\">  <span class=\"keyword\">end</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">end</span>;</span><br></pre></td></tr></table></figure>\n<p>最后，完成代码，完整代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 引入相关库</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> moment = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;moment&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> Op = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;sequelize&#x27;</span>).Op;</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; <span class=\"attr\">v4</span>: uuidv4 &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;uuid&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入数据库model文件</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> seckillModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/seckill_goods&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> ordersModel = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/mysql/models/orders&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入Redis实例</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> redis = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../dbs/redis&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入工具函数或工具类</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> UserModule = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../modules/user&#x27;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; randomString, checkObjNull &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/tools/funcs&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入秒杀key前缀</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; SECKILL_GOOD, LOCK_KEY &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/constants/redis-prefixs&#x27;</span>);</span><br><span class=\"line\"><span class=\"comment\">// 引入避免超卖lua脚本</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> &#123; stock, lock, unlock &#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;../../utils/scripts&#x27;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Seckill</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">async</span> <span class=\"function\"><span class=\"title\">doSeckill</span>(<span class=\"params\">ctx, next</span>)</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> body = ctx.request.body;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> goodId = ctx.params.good_id;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> accessToken = ctx.query.accessToken;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> path = body.path;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 基本参数校验</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!accessToken || !path) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">20001</span>, <span class=\"string\">&#x27;参数错误！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断此产品是否加入了抢购</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> key = <span class=\"string\">`<span class=\"subst\">$&#123;SECKILL_GOOD&#125;</span><span class=\"subst\">$&#123;goodId&#125;</span>`</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> seckill = <span class=\"keyword\">await</span> redis.hgetall(key);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!checkObjNull(seckill)) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30002</span>, <span class=\"string\">&#x27;该产品并未有抢购活动！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否有效</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!seckill.is_valid) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30003</span>, <span class=\"string\">&#x27;该活动已结束！&#x27;</span>); &#125;;</span><br><span class=\"line\">    <span class=\"comment\">// 判单是否开始、结束</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isBefore(moment(seckill.start_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30004</span>, <span class=\"string\">&#x27;该抢购活动还未开始！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(moment().isAfter(moment(seckill.end_time))) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30005</span>, <span class=\"string\">&#x27;该抢购活动已经结束！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 判断是否卖完</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(seckill.amount &lt; <span class=\"number\">1</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//获取登录用户信息(这一步只是简单模拟验证用户身份，实际开发中要有严格的登录注册校验流程)</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> userInfo = <span class=\"keyword\">await</span> UserModule.getUserInfo(accessToken);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!userInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">10002</span>, <span class=\"string\">&#x27;用户不存在！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 判断登录用户是否已抢到</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> orderInfo = <span class=\"keyword\">await</span> ordersModel.findOne(&#123;</span><br><span class=\"line\">      <span class=\"attr\">where</span>: &#123;</span><br><span class=\"line\">        <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">        <span class=\"attr\">good_id</span>: goodId,</span><br><span class=\"line\">        <span class=\"attr\">status</span>: &#123; [Op.between]: [<span class=\"string\">&#x27;0&#x27;</span>, <span class=\"string\">&#x27;1&#x27;</span>] &#125;,</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (orderInfo) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30007</span>, <span class=\"string\">&#x27;该用户已抢到该产品，无需再抢！&#x27;</span>); &#125;;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 加锁，实现一个用户针对这次活动只能购买一次</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> lockKey = <span class=\"string\">`<span class=\"subst\">$&#123;LOCK_KEY&#125;</span><span class=\"subst\">$&#123;userInfo.id&#125;</span>:<span class=\"subst\">$&#123;goodId&#125;</span>`</span>; <span class=\"comment\">// 锁的key有用户id和商品id组成</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> uuid = uuidv4();</span><br><span class=\"line\">    <span class=\"keyword\">const</span> expireTime = moment(seckill.end_time).diff(moment(), <span class=\"string\">&#x27;minutes&#x27;</span>); <span class=\"comment\">// 锁存在时间为当前时间和活动结束的时间差</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> tryLock = <span class=\"keyword\">await</span> redis.eval(lock, <span class=\"number\">2</span>, [lockKey, <span class=\"string\">&#x27;releaseTime&#x27;</span>, uuid, expireTime]);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (tryLock === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 扣库存</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> count = <span class=\"keyword\">await</span> redis.eval(stock, <span class=\"number\">2</span>, [key, <span class=\"string\">&#x27;amount&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>, <span class=\"string\">&#x27;&#x27;</span>]);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>); &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 下单</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> orderData = &#123;</span><br><span class=\"line\">          <span class=\"attr\">order_no</span>: <span class=\"built_in\">Date</span>.now() + randomString(<span class=\"number\">4</span>), <span class=\"comment\">// 这里就用当前时间戳加4位随机数作为订单号，实际开发中根据业务规划逻辑 </span></span><br><span class=\"line\">          <span class=\"attr\">good_id</span>: goodId,</span><br><span class=\"line\">          <span class=\"attr\">user_id</span>: userInfo.id,</span><br><span class=\"line\">          <span class=\"attr\">status</span>: <span class=\"string\">&#x27;1&#x27;</span>, <span class=\"comment\">// -1 已取消, 0 未付款， 1 已付款， 2已退款</span></span><br><span class=\"line\">          <span class=\"attr\">order_type</span>: <span class=\"string\">&#x27;2&#x27;</span>, <span class=\"comment\">// 1 常规订单 2 秒杀订单</span></span><br><span class=\"line\">          <span class=\"comment\">// seckill_id: seckill.id, // 秒杀活动id, redis中不维护秒杀活动id</span></span><br><span class=\"line\">          <span class=\"attr\">comment</span>: <span class=\"string\">&#x27;&#x27;</span>, <span class=\"comment\">// 备注</span></span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> order = ordersModel.create(orderData);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!order) &#123; <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30008</span>, <span class=\"string\">&#x27;抢购失败!&#x27;</span>); &#125;;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">await</span> redis.eval(unlock, <span class=\"number\">1</span>, [lockKey, uuid]);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> ctx.throwException(<span class=\"number\">30006</span>, <span class=\"string\">&#x27;该产品已经卖完了！&#x27;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ctx.send(&#123;</span><br><span class=\"line\">      path,</span><br><span class=\"line\">      <span class=\"attr\">data</span>: <span class=\"string\">&#x27;抢购成功!&#x27;</span></span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"keyword\">new</span> Seckill();</span><br></pre></td></tr></table></figure>\n\n<p>这里代码主要做个四个修改：</p>\n<ol>\n<li>步骤2，判断产品是否加入了抢购，改为去<code>Redis</code>中查询</li>\n<li>步骤7，判断登录用户是否已抢到，因为不在维护抢购活动<code>id</code>，所以改为使用用户<code>id</code>、产品<code>id</code>和状态<code>status</code>判断</li>\n<li>步骤8，扣库存，改为使用<code>lua</code>脚本去<code>Redis</code>中扣库存</li>\n<li>对扣库存和写入数据库操作进行加锁</li>\n</ol>\n<p>订单的操作仍然在<code>Mysql</code>数据库中进行，因为大部分的请求都在步骤5被拦截了，剩余请求<code>Mysql</code>是完全有能力处理的。   </p>\n<p>再次通过<code>Jmeter</code>进行测试，发现订单表正常，库存量扣减正常，说明超卖问题和限购已经解决。</p>\n<h2 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h2><ol>\n<li>秒杀场景的其他技术<br> 基于<code>Redis</code>支持高并发、键值对型数据库和支持原子操作等特点，案例中使用<code>Redis</code>来作为秒杀应对方案。在更复杂的秒杀场景下，除了使用<code>Redis</code>外，在必要的的情况下还需要用到其他一些技术：<ul>\n<li>限流，用漏斗算法、令牌桶算法等进行限流</li>\n<li>缓存，把热点数据缓存到内存里，尽可能缓解数据库访问的压力</li>\n<li>削峰，使用消息队列和缓存技术使瞬间高流量转变成一段时间的平稳流量，比如客户抢购成功后，立即返回响应，然后通过消息队列异步处理后续步骤，发短信，写日志，更新一致性低的数据库等等</li>\n<li>异步，假设商家创建一个只针对粉丝的秒杀活动，如果商家的粉丝比较少（假设小于1000），那么秒杀活动直接推送给所有粉丝，如果用户粉丝比较多，程序立刻推送给排名前1000的用户，其余用户采用消息队列延迟推送。（1000这个数字需要根据具体情况决定，比如粉丝数2000以内的商家占99%，只有1%的用户粉丝超过2000，那么这个值就应该设置为2000）</li>\n<li>分流，单台服务器不行就上集群，通过负载均衡共同去处理请求，分散压力</li>\n</ul>\n 这些技术的应用会让整个秒杀系统更加完善，但是核心技术还是<code>Redis</code>，可以说用好<code>Redis</code>实现的秒杀系统就足以应对大部分场景。</li>\n<li><code>Redis</code>健壮性<br> 案例使用的是单机版<code>Redis</code>，单节点在生产环境基本上不会使用，因为<ul>\n<li>不能达到高可用</li>\n<li>即便有着<code>AOF</code>日志和<code>RDB</code>快照的解决方案以保证数据不丢失，但都只能放在<code>master</code>上，一旦机器故障，服务就无法运行，而且即便采取了相应措施仍不可避免的会造成数据丢失。</li>\n</ul>\n 因此，<code>Redis</code>的主从机制和集群机制在生产环境下是必须的。</li>\n<li><code>Redis</code>分布式锁的问题<ul>\n<li>单点分布式锁，案例提到的分布式锁，实际上更准确的说法是单点分布式锁，是为了方便演示，但是，单点<code>Redis</code>分布式锁是肯定不能用在生产环境的，理由跟第2点类似</li>\n<li>以主从机制（多机器）为基础的分布式锁，也是不够的，因为<code>redis</code>在进行主从复制时是异步完成的，比如在<code>clientA</code>获取锁后，主<code>redis</code>复制数据到从<code>redis</code>过程中崩溃了，导致锁没有复制到从<code>redis</code>中，然后从<code>redis</code>选举出一个升级为主<code>redis</code>，造成新的主<code>redis</code>没有<code>clientA</code>设置的锁，这时<code>clientB</code>尝试获取锁，并且能够成功获取锁，导致互斥失效。</li>\n</ul>\n 针对以上问题，<code>redis</code>官方设计了<code>Redlock</code>，在<code>Node.js</code>环境下对应的资源库为<code>node-redlock</code>，可以用<code>npm</code>安装，至少需要3个独立的服务器或集群才能使用，提供了非常高的容错率，在生产环境中应该优先采用此方案部署。</li>\n</ol>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>秒杀场景的特点可以总结为瞬时并发访问、读多写少、限时和限量，开发中还要考虑避免超卖现象以及类似黄牛抢票的限购问题，针对以上特点和问题，分析得到开发的原则是：数据写入内存而不是写入硬盘，异步处理而不是同步处理，扣库存操作原子执行以及对单用户购买进行加锁，而<code>Redis</code>正好是符合以上全部特点的工具，因此最终选择<code>Redis</code>来解决问题。</p>\n<p>秒杀场景是一个在电商业务中相对复杂的场景，此篇文章只是介绍了其中最核心的逻辑，实际业务可能更加复杂，但只需要在此核心基础上进行扩展和优化即可。<br>秒杀场景的解决方案不仅仅适合秒杀，类似的还有抢红包、抢优惠券以及抢票等等，思路都是一致的。<br>解决方案的思路还可以应用在单独限购、第二件半价以及控制库存等等诸多场景，大家要灵活运用。</p>\n<h2 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h2><p><a href=\"https://github.com/threerocks/redis-seckill\">https://github.com/threerocks/redis-seckill</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"https://time.geekbang.org/column/article/307421\">https://time.geekbang.org/column/article/307421</a><br><a href=\"https://redis.io/topics/distlock\">https://redis.io/topics/distlock</a></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ckqc71guk0001txzbh7pffevl","tag_id":"ckqc71guo0003txzb9n5ac3pi","_id":"ckqc71gut0009txzberrs9out"},{"post_id":"ckqc71guk0001txzbh7pffevl","tag_id":"ckqc71guq0004txzb15l0fbdw","_id":"ckqc71gut000atxzbelac6twm"},{"post_id":"ckqc71guk0001txzbh7pffevl","tag_id":"ckqc71guq0005txzb6v2hgwl2","_id":"ckqc71gut000ctxzb604g6cxz"},{"post_id":"ckqc71guk0001txzbh7pffevl","tag_id":"ckqc71gur0006txzbge4kd1ia","_id":"ckqc71gut000dtxzb04ap7wvo"},{"post_id":"ckqc71guk0001txzbh7pffevl","tag_id":"ckqc71gur0007txzb3noidoga","_id":"ckqc71guu000ftxzbbrb98av1"},{"post_id":"ckqc71gum0002txzb7v1g07wd","tag_id":"ckqc71guq0004txzb15l0fbdw","_id":"ckqc71guv000itxzbetvq62ss"},{"post_id":"ckqc71gum0002txzb7v1g07wd","tag_id":"ckqc71guq0005txzb6v2hgwl2","_id":"ckqc71guv000jtxzbeza6cq4l"},{"post_id":"ckqc71gum0002txzb7v1g07wd","tag_id":"ckqc71guu000etxzbgdhxg84n","_id":"ckqc71guv000ktxzbcu89277v"},{"post_id":"ckqc71gum0002txzb7v1g07wd","tag_id":"ckqc71guu000gtxzbalep533g","_id":"ckqc71guv000ltxzbc3pjbv96"},{"post_id":"ckqc71gum0002txzb7v1g07wd","tag_id":"ckqc71guu000htxzb69a9hem5","_id":"ckqc71guv000mtxzbfanvg930"}],"Tag":[{"name":"Promise","_id":"ckqc71guo0003txzb9n5ac3pi"},{"name":"Node.js","_id":"ckqc71guq0004txzb15l0fbdw"},{"name":"Javascript","_id":"ckqc71guq0005txzb6v2hgwl2"},{"name":"ES6","_id":"ckqc71gur0006txzbge4kd1ia"},{"name":"异步","_id":"ckqc71gur0007txzb3noidoga"},{"name":"Mysql","_id":"ckqc71guu000etxzbgdhxg84n"},{"name":"Redis","_id":"ckqc71guu000gtxzbalep533g"},{"name":"秒杀","_id":"ckqc71guu000htxzb69a9hem5"}]}}